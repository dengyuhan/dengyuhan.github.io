{"meta":{"title":"闲蛋的笔记","subtitle":null,"description":null,"author":"xiandan","url":"https://xiandan.in"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-19T13:42:54.592Z","updated":"2019-07-19T13:42:54.592Z","comments":false,"path":"/404.html","permalink":"https://xiandan.in//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-14T16:27:39.507Z","updated":"2019-07-19T13:42:54.645Z","comments":true,"path":"about/index.html","permalink":"https://xiandan.in/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-12-16T08:55:18.163Z","updated":"2018-12-16T08:55:18.163Z","comments":false,"path":"books/index.html","permalink":"https://xiandan.in/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-16T08:55:18.163Z","updated":"2018-12-16T08:55:18.163Z","comments":false,"path":"categories/index.html","permalink":"https://xiandan.in/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-12-16T08:55:18.163Z","updated":"2018-12-16T08:55:18.163Z","comments":true,"path":"links/index.html","permalink":"https://xiandan.in/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-12-16T08:55:18.163Z","updated":"2018-12-16T08:55:18.163Z","comments":false,"path":"repository/index.html","permalink":"https://xiandan.in/repository/index.html","excerpt":"","text":""},{"title":"贡献","date":"2019-02-04T07:07:59.852Z","updated":"2019-02-04T07:03:51.145Z","comments":false,"path":"contribution/index.html","permalink":"https://xiandan.in/contribution/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-16T08:55:18.164Z","updated":"2018-12-16T08:55:18.164Z","comments":false,"path":"tags/index.html","permalink":"https://xiandan.in/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git特殊使用场景命令","slug":"git-command","date":"2019-12-31T03:23:01.000Z","updated":"2020-01-04T15:36:45.188Z","comments":true,"path":"posts/git-command.html","link":"","permalink":"https://xiandan.in/posts/git-command.html","excerpt":"","text":"删除已推到远程分支的提交git log复制需要回滚的commit_id，把HEAD指向这个commit_id并强制推送 12git reset --hard [commit_id]git push origin HEAD --force 交互式命令1echo &quot;输入要回滚的commit id&quot; &amp;&amp; read id &amp;&amp; git reset --hard $id &amp;&amp; git push origin HEAD --force 强制更新抛弃当前所有的变更并更新 123git fetch --allgit reset --hard origin/[分支名称]git pull 交互式命令1echo &quot;输入要更新的分支(default: master)&quot; &amp;&amp; read input &amp;&amp; branch=$&#123;input:=master&#125; &amp;&amp; echo 从&quot;$branch&quot;拉取更新 &amp;&amp; git fetch --all &amp;&amp; git reset --hard origin/&quot;$branch&quot; &amp;&amp; git pull 克隆到非空文件夹1234git clone --no-checkout [git_url] tmpmv tmp/.git .rmdir tmpgit reset --hard HEAD 交互式命令克隆并覆盖当前文件夹 1echo &quot;输入要克隆的URL&quot; &amp;&amp; read url &amp;&amp; echo 克隆&quot;$url&quot;到当前文件夹 &amp;&amp; git clone --no-checkout $url tmp &amp;&amp; mv tmp/.git . &amp;&amp; rmdir tmp &amp;&amp; git reset --hard HEAD 更改全局用户名和邮箱全局用户名 1git config --global user.name &quot;[用户名]&quot; 全局邮箱 1git config --global user.email &quot;[邮箱地址]&quot; 给Github设置SSH代理修改或创建config 1vi ~/.ssh/config 设置Github走1080端口 12Host github.comProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://xiandan.in/tags/Git/"}]},{"title":"搬瓦工/Vultr/JustMySocks对比","slug":"bwg-vultr-justmysocks","date":"2019-06-03T07:17:17.000Z","updated":"2019-11-03T16:38:31.326Z","comments":true,"path":"posts/bwg-vultr-justmysocks.html","link":"","permalink":"https://xiandan.in/posts/bwg-vultr-justmysocks.html","excerpt":"","text":"搬瓦工搬瓦工是IT7旗下的VPS品牌，相对国内的VPS性价比很高。 JustMySocksJustMySocks是搬瓦工推出的代理服务，相对VPS也是便宜很多，并且很稳定。 Vultr除了搬瓦工，还有Vultr也可以用，比搬瓦工要贵，但是按小时付费的，所以可以随时更换。 可以先测速再选择适合自己的机房 Vultr的工单处理的很快，快的时候2分钟就回复了，而且可以随时提现余额 对比价格更新于2019-09-23，不排除涨价降价的可能，以官网显示为准 类型 最低档价格 最低档流量 速度 优点 缺点 搬瓦工 VPS $49.99/年 1T/月 正常 硬件配置性价比更高 1.被墙就只能花钱改IP2.最低档的只能年付 Vultr VPS $0.007/时$5/月$60/年 1T/月 略慢 1.可以随时开通和取消2.余额可随时提现3.工单处理快 1.国内访问相对较慢2.价格较高 JustMySocks 服务 $2.88/月$28.88/年 100G/月 正常 1.最便宜2.稳定 不能自定义端口/密码/域名 官网搬瓦工官网：https://bandwagonhost.com搬瓦工官网：https://bwh88.net（国内可访问） Vultr官网：https://www.vultr.com JustMySocks官网：https://justmysocks.netJustMySocks官网：https://justmysocks1.net（国内可访问）","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiandan.in/categories/科学上网/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://xiandan.in/tags/Shadowsocks/"},{"name":"搬瓦工","slug":"搬瓦工","permalink":"https://xiandan.in/tags/搬瓦工/"},{"name":"Vultr","slug":"Vultr","permalink":"https://xiandan.in/tags/Vultr/"},{"name":"JustMySocks","slug":"JustMySocks","permalink":"https://xiandan.in/tags/JustMySocks/"}]},{"title":"搬瓦工被墙后","slug":"bwg-gfw","date":"2019-06-03T07:10:42.000Z","updated":"2019-10-19T22:34:41.131Z","comments":true,"path":"posts/bwg-gfw.html","link":"","permalink":"https://xiandan.in/posts/bwg-gfw.html","excerpt":"","text":"验证是否被墙 在http://port.ping.pe输入服务器IP和SSH端口号，如果国外节点成功国内节点失败说明被墙 也可以登录控制面板，进入到Block List Check，出现IP BLOCKED说明被墙 解决办法咨询了搬瓦工，回复原文如下： 其中提到了几个解决办法： 1.停止服务，也许几天或几周后会解除；2.付费8.79美元更换新的IP；3.使用JustMySocks。 查看 搬瓦工/Vultr/JustMySocks对比 也许有效的预防措施3月1日至17日左右，6月1日至10日左右都是可能被墙的时期，期间最好关机，也许可以防止被墙 亲测解除6月3号被墙，关机直到7月7日再测发现已经解除了","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiandan.in/categories/科学上网/"}],"tags":[{"name":"搬瓦工","slug":"搬瓦工","permalink":"https://xiandan.in/tags/搬瓦工/"},{"name":"Vultr","slug":"Vultr","permalink":"https://xiandan.in/tags/Vultr/"},{"name":"JustMySocks","slug":"JustMySocks","permalink":"https://xiandan.in/tags/JustMySocks/"}]},{"title":"Studio 3T外网远程访问MongoDB","slug":"studio-3t-mongodB","date":"2019-05-29T13:51:02.000Z","updated":"2019-11-03T16:42:36.413Z","comments":true,"path":"posts/studio-3t-mongodB.html","link":"","permalink":"https://xiandan.in/posts/studio-3t-mongodB.html","excerpt":"","text":"Studio 3T：https://studio3t.com/download MongoDB：http://www.mongodb.org 设置MongoDB以宝塔面板为例，进入到MongoDB的配置文件，将bindIp改成0.0.0.0，表示支持任何ip访问，重启MongoDB生效 开放端口如果没开放端口，还需要在防火墙开放MongoDB端口 远程连接MongoDB打开Studio 3T，Connect - New Connection输入服务器IP和MongoDB的端口，保存后直接双击即可连接 添加用户验证以上设置开启了不限制IP并且不需要用户验证，是很不安全的，所以还需要添加用户验证切换至admin数据库 12mongouse admin 添加一个用户 1234567db.createUser( &#123; user: &quot;[用户名]&quot;, pwd: &quot;[密码]&quot;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;) 在配置文件将authorization改为enabled，保存后重启生效 备份(mongodump)与恢复(mongorestore)mongodump备份，如果端口是27017，命令中可以省略 1mongodump -h [地址]:[端口] -d [数据库] -o [备份导出目录] mongorestore恢复，如果端口是27017，命令中可以省略 1mongorestore -h [地址]:[端口] -d [数据库] [备份所在目录]","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xiandan.in/tags/MongoDB/"},{"name":"Studio 3T","slug":"Studio-3T","permalink":"https://xiandan.in/tags/Studio-3T/"}]},{"title":"利用CDN加速你的Github Pages","slug":"github-pages-cdn","date":"2019-04-22T03:22:53.000Z","updated":"2019-11-03T16:44:23.404Z","comments":true,"path":"posts/github-pages-cdn.html","link":"","permalink":"https://xiandan.in/posts/github-pages-cdn.html","excerpt":"","text":"最近发现Github Pages有时候打开很慢，甚至打不开，ping一下平均200多毫秒，还有超时的情况 再看一下网站测速也很慢，移动更是全部超时 开通CDN这里我用的是阿里云的全站加速，具体资费看全站加速价格 也可以用腾讯云，目前免费300G流量 添加域名开通全站加速后到控制台添加域名，在加速域名填写你的域名，选择源站域名，填写你的Github Page地址，如果开启了HTTPS就选择443端口，加速的区域不同地方不同价格，这个看自己需求。 添加成功后会生成一个CNAME地址，将你的域名解析到这个地址，如果你的域名也是阿里云的，可以在控制台一键配置。这个不是实时生效的，如果解析后发现没有生效可以等一段时间再看。 测试效果再次ping你的域名，会发现跳转是你CDN的地址，不再是github.io，加速效果也很明显 再看一下网站测速中国地图一片绿","categories":[{"name":"工具","slug":"工具","permalink":"https://xiandan.in/categories/工具/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"https://xiandan.in/tags/Github-Pages/"},{"name":"CDN","slug":"CDN","permalink":"https://xiandan.in/tags/CDN/"}]},{"title":"Mac安装Elastic Stack和基础配置","slug":"elastic-stack-install","date":"2019-04-18T08:22:42.000Z","updated":"2019-10-19T22:34:41.119Z","comments":true,"path":"posts/elastic-stack-install.html","link":"","permalink":"https://xiandan.in/posts/elastic-stack-install.html","excerpt":"","text":"简介Elastic官网：https://www.elastic.coElastic Github：https://github.com/elastic Elasticsearch： 全文搜索引擎 Kibana：可视化分析平台 Filebeat：日志采集 安装Elasticsearch1brew install elastic/tap/elasticsearch-full Kibana1brew install elastic/tap/kibana-full Filebeat1brew install elastic/tap/filebeat-full 配置配置Filebeat匹配要输入的Log文件路径 1vim /usr/local/etc/filebeat/filebeat.yml 开启Kibana中文打开配置文件，将i18n.locale的注释去掉，改成zh-CN 1vim /usr/local/etc/kibana/kibana.yml 启动前台启动需要3个终端窗口，分别启动 123filebeat -e -d &quot;publish&quot;elasticsearchkibana 后台启动123nohup filebeat -e -d &quot;publish&quot; &gt;/dev/null 2&gt;log &amp;nohup elasticsearch &gt;/dev/null 2&gt;log &amp;nohup kibana &gt;/dev/null 2&gt;log &amp; 全部启动完成后，打开浏览器访问 http://localhost:5601 *添加Apache日志将数据添加到 Kibana 将setup.kibana中的host注释去掉 1vim /usr/local/etc/filebeat/filebeat.yml 开启Apache 12filebeat modules enable apachefilebeat setup 修改apache的Log路径 1vim /usr/local/etc/filebeat/modules.d/apache.yml","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Elastic Stack","slug":"Elastic-Stack","permalink":"https://xiandan.in/tags/Elastic-Stack/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://xiandan.in/tags/Elasticsearch/"},{"name":"Kibana","slug":"Kibana","permalink":"https://xiandan.in/tags/Kibana/"},{"name":"Filebeat","slug":"Filebeat","permalink":"https://xiandan.in/tags/Filebeat/"},{"name":"日志分析","slug":"日志分析","permalink":"https://xiandan.in/tags/日志分析/"}]},{"title":"Android Studio多设备同步配置","slug":"android-studio-sync","date":"2019-04-17T11:50:56.000Z","updated":"2019-06-03T13:29:49.400Z","comments":true,"path":"posts/android-studio-sync.html","link":"","permalink":"https://xiandan.in/posts/android-studio-sync.html","excerpt":"","text":"JetBrains全家桶都有一个Settings Repository功能，可以把IDE的配置同步到Git仓库中，这里用Github做例子，来实现多设备同步IDE配置。 创建保存配置的仓库在Github创建一个仓库后，复制git地址 配置Git URLFile - Settings Repository填入刚刚的git地址 Overwrite Remote：上传配置，用本地配置覆盖仓库。Overwrite Local：下载配置，用仓库配置覆盖本地。Merge：将仓库配置和本地配置进行合并。 上传配置到仓库点击Overwrite Remote会开始上传配置，出现Settings successfully synced说明同步成功 刷新页面可以看到配置文件已经全部上传到仓库了 恢复配置到本地如果需要在另一台设备恢复配置，在Settings Repository配置仓库的git地址后执行Overwrite Local即可","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://xiandan.in/tags/Android-Studio/"},{"name":"同步","slug":"同步","permalink":"https://xiandan.in/tags/同步/"}]},{"title":"Github短信验证码没有中国区的解决办法","slug":"github-verification-code","date":"2019-04-08T06:07:40.000Z","updated":"2019-11-03T16:44:57.091Z","comments":true,"path":"posts/github-verification-code.html","link":"","permalink":"https://xiandan.in/posts/github-verification-code.html","excerpt":"","text":"在Github短信支持列表的国家上是没有中国的 后来看到xcatliu提供的思路，我试了一下是可以收到验证码的，所以我在这里放一个更简单的方法 手动添加+86打开开发者工具，复制代码到控制台执行 123var option = new Option(&quot;China +86&quot;,&quot;+86&quot;);option.selected = true;document.getElementById(&apos;countrycode&apos;).options.add(option, 0);","categories":[{"name":"Github","slug":"Github","permalink":"https://xiandan.in/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://xiandan.in/tags/Github/"}]},{"title":"Mac在Docker里的CentOS安装宝塔面板","slug":"mac-docker-centos-bt","date":"2019-04-01T14:33:16.000Z","updated":"2019-11-03T16:42:59.518Z","comments":true,"path":"posts/mac-docker-centos-bt.html","link":"","permalink":"https://xiandan.in/posts/mac-docker-centos-bt.html","excerpt":"","text":"相关官网 Docker：https://www.docker.com Kitematic：https://kitematic.com 宝塔面板：https://www.bt.cn 安装Docker1brew cask install docker 在Docker里安装CentOSDocker Hub：https://hub.docker.com/_/centos 1docker pull centos 也可以在Kitematic里搜索CentOS安装 映射宝塔端口创建一个CentOS容器并映射8888端口，复制返回的容器ID 1docker run -d -it -p 8888:8888 centos 进入CentOS安装宝塔进入容器终端 1docker exec -it [容器ID] bash 在CentOS中执行宝塔安装命令 1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 安装完成后，提示给的外网IP是用不了的，所以这里需要用本地ip访问面板 相关命令Docker 命令大全 列出正在运行的容器信息 1docker ps 列出所有容器信息 1docker ps -a 停止所有容器 1docker stop $(docker ps -a -q)","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xiandan.in/tags/Docker/"},{"name":"CentOS","slug":"CentOS","permalink":"https://xiandan.in/tags/CentOS/"},{"name":"Kitematic","slug":"Kitematic","permalink":"https://xiandan.in/tags/Kitematic/"}]},{"title":"用Apple Configurator 2提取ipa文件","slug":"get-ipa","date":"2019-02-26T14:48:17.000Z","updated":"2019-02-26T15:10:42.692Z","comments":true,"path":"posts/get-ipa.html","link":"","permalink":"https://xiandan.in/posts/get-ipa.html","excerpt":"","text":"安装Apple Configurator 2从Mac AppStore安装Apple Configurator 2 下载ipa打开后连接设备，选中设备点击添加，如果没登录就登录Apple ID，登录后会把你在AppStore下过的应用都列出来，选一个添加 因为手机上已经装了这个应用，所以最后一步会提示是否替换，不要做任何操作，保持这个状态 提取ipa用Finder前往文件夹进到下面的路径 1~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 一直进到最里面的文件夹，会发现刚刚下载的ipa文件","categories":[{"name":"工具","slug":"工具","permalink":"https://xiandan.in/categories/工具/"}],"tags":[{"name":"Apple Configurator","slug":"Apple-Configurator","permalink":"https://xiandan.in/tags/Apple-Configurator/"},{"name":"ipa","slug":"ipa","permalink":"https://xiandan.in/tags/ipa/"}]},{"title":"让wepy在WebStorm支持代码高亮","slug":"wepy-webstorm","date":"2019-02-25T09:45:26.000Z","updated":"2019-09-01T14:35:50.909Z","comments":true,"path":"posts/wepy-webstorm.html","link":"","permalink":"https://xiandan.in/posts/wepy-webstorm.html","excerpt":"","text":"支持wpyPreferences - Editor - File Types选择Vue.js Template，添加*.wpy 支持特殊标签Preferences - Editor - Language Injections添加XML Tag Injection 高亮config标签Namespace用http://www.w3.org/1999/html 高亮wxs标签 支持rpxPreferences - Tools - File Watchers添加custom Program: sedArguments: —i “ s/”\\ rpx”/rpx/g $FilePath$Output paths to refresh: $FilePath$ *如果是Windows需要先安装sed-windows，Program则换成sed的安装路径 效果","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"https://xiandan.in/tags/WebStorm/"},{"name":"wepy","slug":"wepy","permalink":"https://xiandan.in/tags/wepy/"},{"name":"小程序","slug":"小程序","permalink":"https://xiandan.in/tags/小程序/"}]},{"title":"Centos/Mac安装Node.js环境教程","slug":"install-nodejs","date":"2019-02-25T04:41:22.000Z","updated":"2019-08-31T12:35:54.718Z","comments":true,"path":"posts/install-nodejs.html","link":"","permalink":"https://xiandan.in/posts/install-nodejs.html","excerpt":"","text":"CentOS1curl --silent --location https://rpm.nodesource.com/setup_12.x | bash - 1yum install -y nodejs Mac1brew install nodejs","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://xiandan.in/tags/Node-js/"},{"name":"Centos","slug":"Centos","permalink":"https://xiandan.in/tags/Centos/"},{"name":"Mac","slug":"Mac","permalink":"https://xiandan.in/tags/Mac/"}]},{"title":"Git完全复制一个Repository到新Repository","slug":"git-mirror","date":"2019-02-22T03:02:32.000Z","updated":"2019-02-24T07:48:49.335Z","comments":true,"path":"posts/git-mirror.html","link":"","permalink":"https://xiandan.in/posts/git-mirror.html","excerpt":"","text":"先clone一份被复制的Repository到本地 1git clone [old repository url] 进入到旧仓库目录，通过mirror参数推送到新的Repository 12cd [old repository]git push --mirror [new repository url] 这样就会把旧仓库原样的复制到新仓库上，包括所有的分支、提交记录等等，当然这个也适用于Github","categories":[{"name":"工具","slug":"工具","permalink":"https://xiandan.in/categories/工具/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://xiandan.in/tags/Github/"},{"name":"Git","slug":"Git","permalink":"https://xiandan.in/tags/Git/"}]},{"title":"通过油猴脚本让直播平台自动网页全屏","slug":"tampermonkey-live-fullscreen","date":"2019-02-12T08:24:29.000Z","updated":"2019-12-31T14:26:11.702Z","comments":true,"path":"posts/tampermonkey-live-fullscreen.html","link":"","permalink":"https://xiandan.in/posts/tampermonkey-live-fullscreen.html","excerpt":"","text":"Github：https://github.com/xiandanin/LardMonkeyScripts 看直播的时候，我个人习惯是关了弹幕开网页全屏，但是一般直播网站都是默认打开弹幕，每次都都要手动点一下很麻烦，所以写了个油猴脚本，进入直播间后会自动网页全屏和关弹幕。 已经测试Windows、Mac，Chrome、360浏览器均有效 安装油猴Chrome 直接插件商店安装：Tampermonkey 360浏览器 在扩展中心搜索Tampermonkey 安装油猴脚本到greasyfork安装直播平台自动网页全屏 目前支持斗鱼、熊猫、虎牙 熊猫TV需要切换成H5播放器才有效果","categories":[{"name":"工具","slug":"工具","permalink":"https://xiandan.in/categories/工具/"}],"tags":[{"name":"Tampermonkey","slug":"Tampermonkey","permalink":"https://xiandan.in/tags/Tampermonkey/"},{"name":"直播","slug":"直播","permalink":"https://xiandan.in/tags/直播/"}]},{"title":"使用Homebrew安装初始化Google Cloud SDK","slug":"google-cloud-sdk-homebrew","date":"2019-01-28T11:07:24.000Z","updated":"2019-09-01T14:35:40.293Z","comments":true,"path":"posts/google-cloud-sdk-homebrew.html","link":"","permalink":"https://xiandan.in/posts/google-cloud-sdk-homebrew.html","excerpt":"","text":"官方文档 准备工作1、 先在控制台创建一个应用 2、 python -V查看python版本，至少2.7以上 安装使用brew安装Google Cloud SDK 1brew cask install google-cloud-sdk 如果安装过程中报如下错： 1Error: Permission denied @ dir_s_mkdir - /usr/local/Caskroom/google-cloud-sdk/latest 可以尝试手动赋予权限，再重新调用安装命令 1sudo chown -R $(whoami) /usr/local/Cellar 执行gcloud有打印出帮助，说明已经安装完成 初始化执行初始化命令 1gcloud init 执行后会询问登录，直接回车 1To continue, you must log in. Would you like to log in (Y/n)? 登录完成后，会要求选择一个项目，输入一个项目编号等待完成","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Google Cloud SDK","slug":"Google-Cloud-SDK","permalink":"https://xiandan.in/tags/Google-Cloud-SDK/"}]},{"title":"Splash适配解决启动图拉伸的问题","slug":"android-splash-compat","date":"2019-01-28T05:55:06.000Z","updated":"2019-12-31T14:26:11.697Z","comments":true,"path":"posts/android-splash-compat.html","link":"","permalink":"https://xiandan.in/posts/android-splash-compat.html","excerpt":"","text":"https://github.com/xiandanin/SplashCompatSample 前言做过Splash的都知道，一般的做法是在style中设置windowBackground为启动图，来避免冷启动时的黑屏，但是如果放一张尺寸的图在某些屏幕上就会出现拉伸，并且windowBackground还不能centerCrop，就算通过资源限定符也不能完美的适配。 效果左边是小米5S（1080x1920），右边是小米MIX2（全面屏1080x2160） 适配过程这个例子比较简单，在显示windowBackground时白色背景+slogan，跳到SplashActivity后上面广告+下面slogan 1. windowBackground首先需要解决windowBackground的拉伸问题，用一整张图肯定不行，所以这里只需要一张slogan图片，然后通过layer-list来实现。 在drawable下建一个splash.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!--白色矩形 作为背景色--&gt; &lt;item&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@android:color/white&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--单独的slogan图片 并且设置下间距--&gt; &lt;item android:bottom=&quot;@dimen/margin_vertical_splash&quot;&gt; &lt;!--位置设置成靠下--&gt; &lt;bitmap android:gravity=&quot;bottom&quot; android:src=&quot;@drawable/splash_logo&quot; /&gt; &lt;/item&gt;&lt;/layer-list&gt; 2. Activity Theme新建一个Splash主题，windowBackground设置成刚刚建的splash.xml 1234&lt;style name=&quot;AppTheme.Splash&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash&lt;/item&gt;&lt;/style&gt; 将SplashActivity设成Splash主题 12345678&lt;activity android:name=&quot;.SplashActivity&quot; android:theme=&quot;@style/AppTheme.Splash&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 看看效果，在有NavigationBar的手机上，slogan图片被遮住了。 在5.0后，增加了一个windowDrawsSystemBarBackgrounds属性，用来标志此窗口是否负责绘制系统栏背景，我们把它设成false，这样当它绘制windowBackground的时候，就会在NavigationBar之上。 因为这个属性是5.0以后才有的，所以需要新建values-v21文件夹，以便5.0以上的机器使用v21的Splash主题。 12345&lt;style name=&quot;AppTheme.Splash&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash&lt;/item&gt; &lt;item name=&quot;android:windowDrawsSystemBarBackgrounds&quot;&gt;false&lt;/item&gt;&lt;/style&gt; 3. SplashActivity因为主题中设置的windowBackground，可以不需要在Activity中再放slogan图片了，只需要放一个广告图片，设置marginBottom给slogan留出位置就可以 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;120dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/ad&quot; /&gt;&lt;/RelativeLayout&gt; 总结适配启动图的核心代码就是layer-list，将元素叠成启动图的样式，了解了这个知识点，更复杂一点的启动图也是可以适配的。 如果对layer-list不了解可以看官方文档（中文的）。","categories":[{"name":"Android 适配","slug":"Android-适配","permalink":"https://xiandan.in/categories/Android-适配/"}],"tags":[{"name":"Splash","slug":"Splash","permalink":"https://xiandan.in/tags/Splash/"},{"name":"适配","slug":"适配","permalink":"https://xiandan.in/tags/适配/"}]},{"title":"如何真实有效的用代码滚动AppBarLayout","slug":"appbar-srcoll","date":"2018-12-25T02:56:44.000Z","updated":"2019-12-31T14:26:11.701Z","comments":true,"path":"posts/appbar-srcoll.html","link":"","permalink":"https://xiandan.in/posts/appbar-srcoll.html","excerpt":"","text":"Github地址：https://github.com/xiandanin/AndroidViewHelper 效果图 Gradle 引入1implementation &apos;com.dyhdyh:view-helper:1.0.3&apos; 调用DesignViewHelper12345678//滚动AppBarLayoutDesignViewHelper.setAppBarLayoutOffset(appBar, offsetY);//以动画的形式滚动AppBarLayoutDesignViewHelper.setAppBarLayoutOffsetWithAnimate(appBar, offsetY, duration);//滚动AppBarLayout到顶部DesignViewHelper.scrollAppBarTop(appBar, isAnimate); 篇外话得吐槽一下国内的技术文章环境是真的烂，这个问题查来查去不是你抄他就是他抄你，没有一篇能够有效的让AppBarLayout滚动，那没办法只能自己解决了。 翻了老半天的源码，最终在HeaderBehavior中找到了setHeaderTopBottomOffset，过程很艰辛，结果很简单，但是这个方法不是public的调不到，所以要用反射去调，已经封装在DesignViewHelper，可以直接使用。 1234567891011121314151617int setHeaderTopBottomOffset(CoordinatorLayout parent, V header, int newOffset) &#123; return this.setHeaderTopBottomOffset(parent, header, newOffset, -2147483648, 2147483647);&#125;int setHeaderTopBottomOffset(CoordinatorLayout parent, V header, int newOffset, int minOffset, int maxOffset) &#123; int curOffset = this.getTopAndBottomOffset(); int consumed = 0; if (minOffset != 0 &amp;&amp; curOffset &gt;= minOffset &amp;&amp; curOffset &lt;= maxOffset) &#123; newOffset = MathUtils.clamp(newOffset, minOffset, maxOffset); if (curOffset != newOffset) &#123; this.setTopAndBottomOffset(newOffset); consumed = curOffset - newOffset; &#125; &#125; return consumed;&#125;","categories":[{"name":"Material Design","slug":"Material-Design","permalink":"https://xiandan.in/categories/Material-Design/"}],"tags":[{"name":"AppBarLayout","slug":"AppBarLayout","permalink":"https://xiandan.in/tags/AppBarLayout/"}]},{"title":"Homebrew安装指定版本软件","slug":"homebrew-historic-version","date":"2018-12-06T08:53:12.000Z","updated":"2019-02-04T06:35:25.021Z","comments":true,"path":"posts/homebrew-historic-version.html","link":"","permalink":"https://xiandan.in/posts/homebrew-historic-version.html","excerpt":"","text":"相关链接https://stackoverflow.com/questions/39187812/homebrew-how-to-install-older-versionshttps://stackoverflow.com/questions/3987683/homebrew-install-specific-version-of-formula 以安装groovy为例，最新的是2.5.4，但我需要安装2.4.91.在homebrew-core直接搜索groovy 2.4.9，找到该版本的提交记录 2.查看groovy.rb，这样就得到了历史版本的文件地址 3.直接用brew安装1brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/e091f8904349d6686637c9e0342b525cd58807db/Formula/groovy.rb","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"https://xiandan.in/tags/Homebrew/"}]},{"title":"scrcpy - Android无需ROOT的跨平台投屏工具","slug":"scrcpy","date":"2018-10-24T11:27:21.000Z","updated":"2019-12-31T14:26:11.698Z","comments":true,"path":"posts/scrcpy.html","link":"","permalink":"https://xiandan.in/posts/scrcpy.html","excerpt":"","text":"前言之前有提到Vysor，但是这个插件免费版的码率比较低，如果要高清的就要付费。现在推荐一个Genymotion推出的投屏工具，跨平台，自定义码率，最重要的是开源，简直良心。 Github：https://github.com/Genymobile/scrcpy下载地址：https://github.com/Genymobile/scrcpy/releases 效果图gif录制较模糊，实际使用很清晰 设备要求Android 5.0以上 检查ADB在命令行里打adb，如果有反应就说明已经有ADB，如果提示command not found就说明没有安装ADB 如果没有ADB需要先安装ADBWindowsMac OSLinux 安装scrcpyWindows scrcpy-win32-v1.12.1.zip scrcpy-win64-v1.12.1.zip Mac OS可以通过Homebrew直接安装1brew install scrcpy LinuxArch Linux scrcpy scrcpy-prebuiltserver 其它版本的Linux需要手动构建手动构建文档 打开USB调试在 开发人员选项 打开 USB调试，USB连接手机 命令行执行启动scrcpy 1scrcpy 如果有多个设备，需要指定序列号，序列号可以从adb devices获得 1scrcpy -s a1171b8 设置端口 1scrcpy -p 27184 查看帮助 1scrcpy --help 设置码率（默认8M） 1scrcpy -b 8M 限制投屏尺寸 1scrcpy -m 1024 裁剪投屏屏幕(长:宽:偏移x:偏移y) 1scrcpy -c 800:800:0:0 投屏并录屏 1scrcpy -r file.mp4 不投屏只录屏 1scrcpy -Nr file.mp4 手指触摸的时候显示轨迹球 1scrcpy -t 显示版本信息 1scrcpy -v 快捷键 Action Shortcut 切换全屏模式 Ctrl+f 将窗口调整为1：1（完美像素） Ctrl+g 调整窗口大小以删除黑色边框 Ctrl+x 或 双击黑色背景 设备HOME键 Ctrl+h 或 鼠标中键 设备BACK键 Ctrl+b 或 鼠标右键 设备任务管理键 Ctrl+s 设备 菜单 键 Ctrl+m 设备音量+键 Ctrl+↑ 设备音量-键 Ctrl+↓ 设备电源键 Ctrl+p 点亮手机屏幕 鼠标右键 复制内容到设备 Ctrl+v 启用/禁用FPS计数器（stdout） Ctrl+i 安装APK 将apk文件拖入投屏 传输文件到设备 将文件拖入投屏（非apk）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"投屏","slug":"投屏","permalink":"https://xiandan.in/tags/投屏/"}]},{"title":"Android反编译工具","slug":"android-decompile-tool","date":"2018-10-24T09:03:43.000Z","updated":"2019-02-24T07:48:49.323Z","comments":true,"path":"posts/android-decompile-tool.html","link":"","permalink":"https://xiandan.in/posts/android-decompile-tool.html","excerpt":"","text":"Apktoolhttps://github.com/iBotPeaches/Apktool 可以反编译apk，也可以重新打包apk下载地址：https://github.com/iBotPeaches/Apktool/releasesbrew安装：brew install apktool文档：https://ibotpeaches.github.io/Apktool/documentationapktool d test.apk dex2jarhttps://github.com/pxb1988/dex2jar 可以将.dex文件反编译成.class文件并打包成jar下载地址：https://github.com/pxb1988/dex2jar/releasesbrew安装：brew install dex2jar文档：https://github.com/pxb1988/dex2jar/wikid2j-dex2jar classes.dex jd-guihttps://github.com/java-decompiler/jd-gui 可以查看.class文件，用来查看dex2jar反编译出的jar下载地址：https://github.com/java-decompiler/jd-gui/releasesbrew安装：brew install jd-gui jadx-guihttps://github.com/skylot/jadx 可以直接浏览反编译后的apk下载地址：https://github.com/skylot/jadx/releases uber-apk-signerhttps://github.com/patrickfav/uber-apk-signer 可以对apk签名，支持V1、V2下载地址：https://github.com/patrickfav/uber-apk-signer/releases文档：https://github.com/patrickfav/uber-apk-signer/blob/master/README.mdjava -jar uber-apk-signer.jar -a [apk路径] --ks [keystore路径] --ksAlias [alias名称] java2smalihttps://github.com/ollide/intellij-java2smali IntelliJ IDEA和Android Studio的插件，可以将Java和Kotlin文件编译为smali下载地址：https://github.com/ollide/intellij-java2smali/releases","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"反编译","slug":"反编译","permalink":"https://xiandan.in/tags/反编译/"}]},{"title":"AssetFile - 像File一样操作Asset资源","slug":"android-asset-file","date":"2018-09-17T06:59:17.000Z","updated":"2019-12-31T14:26:11.693Z","comments":true,"path":"posts/android-asset-file.html","link":"","permalink":"https://xiandan.in/posts/android-asset-file.html","excerpt":"","text":"https://github.com/xiandanin/AssetFile 如果想跳过直接看文档，可以拉到最底前言平时开发中经常会用到Assets，可以让我们把一些资源内置在应用里，但是它使用起来比较麻烦，比如要使用Assets里面的一个文件，需要这样： 12345try &#123; final InputStream stream = getAssets().open(&quot;test.jpg&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 拿到的是InputStream，当需要复制到手机外部存储的时候，还得用FileOutputStream输出到文件，如果需要获取文件夹下面的文件： 12345try &#123; final String[] list = getAssets().list(&quot;test&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 这样获取到的只是文件夹下的文件名，如果要复制整个文件夹到手机目录至少要3步： 遍历； 拼接完整路径； 调用open输出到文件。 强迫症表示很难受，没有Java File的API那么方便，那只能撸一个轮子让它像File一样了。下面的图是用AssetFile做的Assets文件管理器 使用场景先举一个我遇到的场景，在线滤镜和内置滤镜，在线滤镜需要先把配置文件下载到手机目录，内置滤镜就是放在Assets里的，为了方便管理，把两种滤镜都放到统一的目录，AssetFile先解决了一个复制文件夹的问题。 如果要获取下图的滤镜1.json，实际上是这样assetManager.open(filter/group/滤镜1/滤镜1.json)，文件名和文件数量实际上是不受开发控制的，也不可能每次变化都再去修改一遍文件名或者代码，所以AssetFile将多层次文件夹的操作简单化了 AssetFile并没有省略那些流程，只是经过封装，让它使用起来变得更简单了 基本实现首先先来实现一下基本功能，Java的叫File，那我们就叫AssetFile，先暂时存一些基本信息，路径和文件名 1234public class AssetFile &#123; private String assetPath; private String name;&#125; 我们在用File的时候是传文件路径，AssetFile也一样，假设Assets根目录有一个test.jpg文件 1234567891011public class AssetFile &#123; private String assetPath; private String name; public AssetFile(String assetPath) &#123; this.assetPath = assetPath == null ? &quot;&quot; : assetPath; //有/的话会去掉/ int index = assetPath.lastIndexOf(File.separatorChar); this.name = assetPath.substring(index + 1, assetPath.length()); &#125;&#125; 1new AssetFile(&quot;test.jpg&quot;) 文件API基本信息也赋好值了，可以说已经有一个雏形了，现在添加一些常用的API，比如exists()当调用AssetManager.list(assetPath)的时候，如果找不到这个文件，会抛出IOException，所以只要catch到就说明这个文件不存在。 123456789public boolean exists(AssetManager assetManager) &#123; try &#123; assetManager.list(assetPath); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; 12AssetFile file = new AssetFile(&quot;test.jpg&quot;)boolean exists = file.exists(context.getAssets()) 加入文件夹的支持文件的API比较简单，要考虑文件夹就会有一些逻辑了 isDirectory()现在我们加入一个isDirectory ()，用来判断这个路径是否是文件夹，可以获取该路径下的子文件数组，来判断这个路径是不是一个文件夹，如果数组长度大于0说明是一个文件夹。 当然这个方法也有不准确的情况，比如你放了一个空文件夹在Assets里，但是为什么要放一个空文件夹在Assets里呢，所以这个方法还是可行的。 这里还有一个处理，assetManager.list()是把子文件的路径都添加到数组里了，所以不能每次都这样取一次子文件数组，可以用一个变量来缓存它，当它有值的时候，就直接用变量的值了。 123456789101112131415public class AssetFile &#123; private Boolean directory; public boolean isDirectory(AssetManager assetManager) &#123; if (directory == null) &#123; try &#123; directory = assetManager.list(assetPath).length &gt; 0; &#125; catch (Exception e) &#123; e.printStackTrace(); directory = false; &#125; &#125; return directory; &#125;&#125; getParent()还有一个常用的方法就是获取父文件夹，这个比较简单，通过分割路径字符串就可以实现。 比如A文件夹里放了B文件夹，B文件夹放了C文件，那路径其实就是A/B/C.jpg，通过substring从0开始截取到最后的/，截取后的A/B就是父文件夹的路径了。 12345678public String getParent() &#123; int index = assetPath.lastIndexOf(File.separatorChar); return assetPath.substring(0, index);&#125;public AssetFile getParentFile() &#123; return new AssetFile(getParent());&#125; listFiles()既然有文件夹，就肯定会需要用到listFiles()，assetManager.list()提供的只是子文件的文件名称，所以需要把它拼接成完整的路径传给AssetFile。 还可以添加一个AssetFileFilter，return false的就不添加到集合;了。当根目录的时候调用assetManager.list会把系统自带的一些文件列出来，所以这里还实现了一个SystemAssetFileFilter，用来过滤这些文件。 12345678910111213141516171819202122232425262728public List&lt;AssetFile&gt; listFiles(AssetManager assetManager) &#123; return listFiles(assetManager, new SystemAssetFileFilter());&#125;public List&lt;AssetFile&gt; listFiles(AssetManager assetManager, AssetFileFilter filter) &#123; try &#123; String newAssetPath = TextUtils.isEmpty(assetPath) ? &quot;&quot; : assetPath; //先获取子文件数组 String[] list = assetManager.list(newAssetPath); List&lt;AssetFile&gt; fileList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.length; i++) &#123; AssetFile file = new AssetFile(newAssetPath, list[i]); if (filter != null) &#123; //如果有过滤器，返回true的才添加到AssetFile集合 if (filter.accept(file)) &#123; fileList.add(file); &#125; &#125; else &#123; //否则直接添加 fileList.add(file); &#125; &#125; return fileList; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return new ArrayList&lt;&gt;();&#125; AssetsManager为了更方便的使用，可以再扩展一个AssetsManager，提供一些辅助性的方法，比如从Assets复制资源到手机目录，复制文件很简单，拿到流之后直接输出到文件，复制文件夹需要递归来达到复制多层文件夹的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 复制Asset文件夹和里面的文件到手机目录 * * @param assetSource * @param outputDir */public static boolean copyAsset(AssetManager assetManager, AssetFile assetSource, File outputDir) &#123; try &#123; File outputFile = new File(outputDir, assetSource.getName()); String assetPath = assetSource.getAssetPath(); final String[] list = assetManager.list(assetPath); if (list.length &lt;= 0) &#123; //文件 copyAssetFile(assetManager, assetPath, outputFile); &#125; else &#123; //目录 if (!outputFile.exists()) &#123; outputFile.mkdirs(); &#125; for (String child : list) &#123; copyAsset(assetManager, new AssetFile(assetPath, child), outputFile); &#125; &#125; return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false;&#125;/** * 复制Asset文件到手机目录 * * @param assetPath * @param outputFile * @return */public static boolean copyAssetFile(AssetManager assetManager, String assetPath, File outputFile) &#123; try &#123; InputStream is = assetManager.open(assetPath); int byteRead = 0; FileOutputStream fs = new FileOutputStream(outputFile); byte[] buffer = new byte[1024]; while ((byteRead = is.read(buffer)) != -1) &#123; fs.write(buffer, 0, byteRead); &#125; fs.close(); is.close(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false;&#125; 文档Gradle引入1implementation &apos;com.dyhdyh.io:asset-file:1.0.2&apos; AssetFile12345678910111213141516171819202122232425262728293031//根目录AssetFile root = new AssetFile();//根目录下的test.jpgAssetFile testFile = new AssetFile(&quot;test.jpg&quot;);//test文件夹下的test.jpg - test/test.jpgAssetFile testFile = new AssetFile(&quot;test/test.jpg&quot;);AssetFile testFile = new AssetFile(&quot;test&quot;, &quot;test.jpg&quot;);//获取完整路径assetFile.getAssetPath();//获取文件名称或目录名称assetFile.getName();//获取父级目录assetFile.getParentFile();//转换UriassetFile.getUri();//是否文件夹assetFile.isDirectory(getAssets());//是否根目录assetFile.isRootDir();//文件是否存在assetFile.exists(getAssets());//获取目录下的文件数组assetFile.listFiles(getAssets()); AssetsManager1234567//复制Assets里的test.jpg到手机根目录AssetFile assetFile = new AssetFile(&quot;test.jpg&quot;);File outputFile = new File(Environment.getExternalStorageDirectory(), assetFile.getName());AssetsManager.copyAssetFile(getAssets(), assetFile.getAssetPath(), outputFile);//复制Assets里的test文件夹到手机根目录AssetsManager.copyAssetFile(getAssets(), &quot;test&quot;, Environment.getExternalStorageDirectory());","categories":[{"name":"Android 开源","slug":"Android-开源","permalink":"https://xiandan.in/categories/Android-开源/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"Assets","slug":"Assets","permalink":"https://xiandan.in/tags/Assets/"}]},{"title":"使用android-gpuimage的一些问题总结","slug":"android-gpuimage-support","date":"2018-06-28T13:32:39.000Z","updated":"2019-12-31T14:26:11.700Z","comments":true,"path":"posts/android-gpuimage-support.html","link":"","permalink":"https://xiandan.in/posts/android-gpuimage-support.html","excerpt":"","text":"前言android-gpuimage虽然可以实现滤镜的效果，但遇到稍微复杂的需求，框架本身的bug和一些缺陷就暴露出来了，而且这个项目最后一个版本是1.4.1，已经2年没维护过了，提issues也没人讨论，这里总结一些遇到的问题和解决办法。 1、Demo跑起来就有些bugandroid-gpuimage-support 重写了更友好的示例 2、异步调用getBitmapWithFilterApplied有时候是黑色在子线程调用getBitmapWithFilterApplied，出来的bitmap是全黑的，但是在主线程就不会有问题。 预览设置的Filter对象跟生成的Filter需要是不同的对象，android-gpuimage-support 增加了GPUImageOutput，可以更方便的输出Bitmap或文件。这里示例RxJava2的调用方式，自定义Filter建议手动创建新对象然后setFilter123456789101112new GPUImageOutput(gpuimage) //.setFilter()//这里需要新创建的Filter .setFilterByClass(filter)//这里可以跟预览Filter用同一个对象 .getFilterBitmap(GPUImageRxJava2Adapter.&lt;Bitmap&gt;create()) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new SimpleLoadingDialogObserver&lt;Bitmap&gt;(v.getContext()) &#123; @Override public void onNext(Bitmap bitmap) &#123; super.onNext(bitmap); &#125; &#125;); 3、RxJava的支持使用android-gpuimage-support的GPUImageOutput，添加了RxJava1和RxJava2的支持123456789101112131415new GPUImageOutput(gpuImage) .setFilter(filter) .setOutputFormat(Bitmap.CompressFormat.JPEG)//输出格式 .setQuality(80)//输出质量 .setOutputFile(outputFile) .outputFilterBitmap(GPUImageRxJava2Adapter.&lt;File&gt;create())//这里可以切换RxJava1和RxJava2 .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new SimpleLoadingDialogObserver&lt;File&gt;(this) &#123; @Override public void onNext(File file) &#123; super.onNext(file); Toast.makeText(MainActivity.this, &quot;保存成功-&gt;&quot; + file.getAbsolutePath(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 4、用TextureView来预览GPUImage的效果android-gpuimage-support添加了支持GPUImage的TextureView1234&lt;jp.co.cyberagent.android.gpuimage.view.GPUImageTextureView android:id=&quot;@+id/texture&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 5、多次设置GPUImageFilterGroup背景会出现错乱当ScaleType为CENTER_INSIDE的时候，在使用GPUImageFilterGroup添加多个Filter的时候，首次setFilter(group)不会有问题，再设置就会背景出现错乱（单个Filter不会出现这种情况） 暂时弄了2种办法：&nbsp;&nbsp;&nbsp;&nbsp;1、ZongwenSun在 #395 提到在GPUImageFilter.onDraw中添加GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);，可以解决。 &nbsp;&nbsp;&nbsp;&nbsp;2、通过图片来动态改变View的宽高12GPUImageTextureView textureView = new GPUImageTextureView(context);textureView.setScaleType(GPUImage.ScaleType.VIEW_FIT_CENTER); 6、GPUImageFilterGroup有时会出现IndexOutOfBoundsException添加多个Filter后，频繁改变子Filter的属性，会导致GPUImageFilterGroup的onDraw方法内出现IndexOutOfBoundsException。猜测是线程问题，目前只能try-catch掉，已经在android-gpuimage-support做相应处理，暂时没有找到更好的解决办法，。 7、GPUImageFilterGroup出现ConcurrentModificationExceptionGPUImageFilterGroup里的Filter集合遍历都是用的foreach，增删子Filter时就会出现此异常，换成for循环即可。已在android-gpuimage-support修复 8、改变GPUImageFilterGroup子Filter属性不刷新调用requestRender没有刷新子Filter的效果，保险一点的办法是重新调用setFilter 9、GPUImageTwoInputFilter让输入源不仅支持Bitmap还支持Filterandroid-gpuimage-support提供了GPUImageTwoInputFilter2，调用setSecondFilter(filter)可以将滤镜作为输入源传入，需要注意的是要放一个GPUImageFilter在它的前面，否则可能回出现输入源的尺寸问题。123GPUImageFilterGroup group=new GPUImageFilterGroup();group.addFilter(new GPUImageFilter());group.addFilter(new GPUImageTwoInputFilter2());","categories":[{"name":"Android 开源","slug":"Android-开源","permalink":"https://xiandan.in/categories/Android-开源/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"GPUImage","slug":"GPUImage","permalink":"https://xiandan.in/tags/GPUImage/"}]},{"title":"Android JNI常见异常解决","slug":"android-jni-error","date":"2018-06-05T15:56:25.000Z","updated":"2019-02-24T07:48:49.322Z","comments":true,"path":"posts/android-jni-error.html","link":"","permalink":"https://xiandan.in/posts/android-jni-error.html","excerpt":"","text":"local reference table overflow (max=512)当使用了大量的局部引用而没有及时释放的话，就可能出现局部引用表溢出，所以变量用完以后回收一下就可以了，需要注意的是参数传的是jobject类型1(*env)-&gt;DeleteLocalRef(env, jobject); input is not valid Modified UTF-8: illegal start byte 0xa9当调用(*env)-&gt;NewStringUTF时会出现，是因为传进去的char*不是UTF-8，转成UTF-8即可；还有一种方法是转成jbyteArray，传到Java后再转成String。C1234567891011void test(const char *text) &#123; int len = strlen(text); if (len &gt; 0) &#123; jbyteArray text_bytes = (*env)-&gt;NewByteArray(env, len); //将C字符串转成jbyteArray (*env)-&gt;SetByteArrayRegion(env, text_bytes, 0, len, (jbyte *) text); //回调给java (*env)-&gt;CallVoidMethod(env, jobject, &quot;javaTest&quot;, text_bytes); (*env)-&gt;DeleteLocalRef(env, text_bytes); &#125;&#125; Java123public void javaTest(byte[] textByteArray) &#123; String text = new String(textByteArray);&#125;","categories":[{"name":"Android NDK","slug":"Android-NDK","permalink":"https://xiandan.in/categories/Android-NDK/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"JNI","slug":"JNI","permalink":"https://xiandan.in/tags/JNI/"}]},{"title":"Spring Boot热部署 - 不重启应用也能看到修改效果","slug":"spring-boot-hot-deployment","date":"2018-05-22T06:27:16.000Z","updated":"2019-09-07T20:06:11.364Z","comments":true,"path":"posts/spring-boot-hot-deployment.html","link":"","permalink":"https://xiandan.in/posts/spring-boot-hot-deployment.html","excerpt":"","text":"只需在Run/Debug Configuration中，把On &#39;Update&#39; action和On frame deactivation全部改为Update classes and resources即可，启动时要用Debug方式启动才有效","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xiandan.in/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiandan.in/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://xiandan.in/tags/Spring-Boot/"}]},{"title":"Spring Boot快速创建Hello World","slug":"spring-boot-helloworld","date":"2018-05-21T15:33:21.000Z","updated":"2019-12-31T14:26:11.697Z","comments":true,"path":"posts/spring-boot-helloworld.html","link":"","permalink":"https://xiandan.in/posts/spring-boot-helloworld.html","excerpt":"","text":"Github地址：https://github.com/xiandanin/SpringBootSample 相关链接https://projects.spring.io/spring-boothttps://www.thymeleaf.org 介绍Spring Boot跟Spring MVC不太一样，Spring MVC建新项目的时候是要配置很多东西的，而Spring Boot讲究的是快速，提供了很多默认配置，所以新建一个项目不需要手动配置任何东西，并且个性化配置也比Spring MVC简单很多。 创建新项目 创建一个新项目，Maven 输入GroupId和ArtifactId 输入项目名称并指定项目存放的路径 引入SpringBoot打开pom.xml，引入SpringBoot1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果提示是否需要开启自动导入，选择Enable Auto-Import，否则更改了pom.xml不会自动更新 创建Application创建SampleApplication，加上注解@SpringBootApplication，这个类的main方法就会成为整个程序的入口，@EnableAutoConfiguration开启自动配置，如果有需要，可以通过@ComponentScan再指定自动扫描的包123456789101112131415package com.springboot.sample;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableAutoConfiguration@SpringBootApplicationpublic class SampleApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(SampleApplication.class, args); &#125; &#125; 创建Controller 创建SampleController，并注解@Controller，加上访问路径的注解 在SampleController内创建一个home方法，在方法上注解@RequestMapping(&quot;/&quot;)，这样就根目录的访问路径注册到这个方法上，当访问http://localhost:8080的时候，就会执行这个方法 这里还注解了@ResponseBody，表示输出Hello World!字符串123456789101112131415161718package com.springboot.sample.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class SampleController &#123; /** * ResponseBody样例 * @return */ @RequestMapping(&quot;/&quot;) @ResponseBody String home() &#123; return &quot;Hello World!&quot;; &#125;&#125; 运行配置Run - Run Configurations + - Applicaltion，Main-Class选择最开始创建的SampleApplicationSpring Boot是不需要发布到外部Tomcat的，所以确定后直接运行即可 测试运行完成后，在浏览器访问http://localhost:8080，就可以看到SampleController的home方法返回的Hello World!了 * hymeleaf支持在Spring Boot中，官方是不推荐使用JSP的，所以我们需要用thymeleaf模板 引入thymeleafpom.xml加入依赖12345&lt;!--thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 创建模板html在resources文件夹下创建templates文件夹，再创建一个index.html 配置访问路径在之前创建的SampleController增加了一个index方法，路径配置到/index，这里加入一个message参数传到页面，再return &quot;index&quot;，这样当访问http://localhost:8080/index的时候，就会跳转到resources/templates文件夹下面的index.html123456789/** * thymeleaf样例 * @return */@RequestMapping(&quot;/index&quot;)String index(Model model) &#123; model.addAttribute(&quot;message&quot;,&quot;Hello Thymeleaf&quot;); return &quot;index&quot;;&#125; 在模板html获取参数在index.html中，用thymeleaf语法获取SampleController添加的message参数。1&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt; 注意还要在html标签上加上命名空间1xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot; 如果你用的是Vue，还需要在script标签上加上th:inline1&lt;script th:inline=&quot;javascript&quot;&gt; 测试在浏览器访问http://localhost:8080/index *导出可执行jar在pom.xml指定包类型并添加插件1&lt;packaging&gt;jar&lt;/packaging&gt; 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行package命令 等待编译成功，会在工程目录的target文件夹下生成一个jar 运行jar命令行cd到target目录1java -jar sample-1.0.0.jar","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xiandan.in/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiandan.in/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://xiandan.in/tags/Spring-Boot/"}]},{"title":"使用Proxifier+Shadowsocks实现Mac全局代理","slug":"mac-global-proxy","date":"2018-03-29T09:52:03.000Z","updated":"2019-07-19T13:42:54.639Z","comments":true,"path":"posts/mac-global-proxy.html","link":"","permalink":"https://xiandan.in/posts/mac-global-proxy.html","excerpt":"","text":"Proxifier可以使Mac上所有的应用都可以走代理，所以也可以让终端和iTerm的网络请求走代理1.下载ProxifierProxifier 2.15破解版 2.配置端口打开Proxifier，打开Proxies - Add，添加代理，IP就是127.0.0.1，端口就是Shadowsocks的端口，如果你没有改过那就是1080 3.添加代理规则Default表示代理所有应用，将Default的Action修改为刚刚配置的端口，就可以让所有的应用都经过代理了 4.测试打开终端输入curl cip.cc，如果返回的是代理服务器的IP那说明就是成功了 1234//以下命令都可以查询ipcurl cip.cccurl ip.cncurl ipinfo.io","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiandan.in/categories/科学上网/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://xiandan.in/tags/Shadowsocks/"},{"name":"Proxifier","slug":"Proxifier","permalink":"https://xiandan.in/tags/Proxifier/"},{"name":"代理","slug":"代理","permalink":"https://xiandan.in/tags/代理/"},{"name":"全局代理","slug":"全局代理","permalink":"https://xiandan.in/tags/全局代理/"}]},{"title":"Shadowsocks/ShadowsocksR客户端全平台安装教程","slug":"shadowsocks-install","date":"2018-03-29T06:26:18.000Z","updated":"2019-10-19T22:34:41.129Z","comments":true,"path":"posts/shadowsocks-install.html","link":"","permalink":"https://xiandan.in/posts/shadowsocks-install.html","excerpt":"","text":"Windows Mac Android iOS Linux 小米路由 服务端推荐使用搬瓦工机场 Windows Shadowsocks：https://github.com/shadowsocks/shadowsocks-windows/releasesShadowsocksR：https://github.com/shadowsocksrr/shadowsocksr-csharp/releases 下载最新版本，解压后打开Shadowsocks.exe，解压后打开Shadowsocks.exe托盘会常驻一个图标，右键托盘图标，服务器 - 服务器设置 配置服务器信息 *浏览器设置如果是360浏览器，需要在浏览器代理设置中选择使用IE代理设置 Mac Shadowsocks：https://github.com/shadowsocks/ShadowsocksX-NG/releasesShadowsocksR：https://github.com/qinyuhang/ShadowsocksX-NG-R/releases 下载最新版，解压后将Shadowsocks拖入应用程序目录，打开后会有一个常驻图标 配置服务器信息打开服务器配置，点击+新增服务器 要使所有程序都支持代理，可以看Mac全局代理 Android Shadowsocks：https://github.com/shadowsocks/shadowsocks-android/releasesShadowsocksR：https://github.com/shadowsocksr-backup/shadowsocksr-android/releases 下载最新版本，安装后选择手动设置，添加一个新节点 配置服务器信息后启动，小飞机绿色说明已经启动成功 快捷启动配置完成后，下次可以不打开app，直接从快捷开关启动，如果快捷开关没有，也可以从系统设置直接启动 iOSShadowsocks-iOS最后更新已经是几年前，所以这里用它的替代品：Outline（仅支持Shadowsocks）、Shadowrocket、Potatso Lite，选择其中一个即可，受国内限制安装比较麻烦，有两种办法。 有国外Apple ID如果有国外的Apple ID，可以切换至国外AppStore搜索下载 Shadowrocket：https://itunes.apple.com/us/app/shadowrocket/id932747118Outline：https://itunes.apple.com/us/app/outline-app/id1356177741Potatso Lite：https://apps.apple.com/us/app/potatso-lite/id1239860606 如果安装过程中出现下面的提示，可以尝试关闭AppStore后，重新登录AppStore再次安装 12your account is not valid for use in the armenian store.you must switch to the u.s. tore before purchasing. 没有国外Apple ID Shadowrocket：Shadowrocket-2.1.10.ipaOutline：Outline-daily-2019-09-03.ipaPotatso Lite：Potatso Lite 2.4.0.ipa 没有国外AppleID则需要通过电脑安装到手机，下载ipa文件，Windows可以用PP助手，Mac用Apple Configurator 2，将ipa安装到设备 Windows - PP助手 PP助手：http://pro.25pp.com 连接设备后，在应用列表手动安装 Mac - Apple Configurator 2 Apple Configurator 2：https://apps.apple.com/cn/app/apple-configurator-2/id1037126344 从Mac AppStore安装Apple Configurator 2 打开后连接设备，选中设备点击添加，从我的Mac选取...选择刚刚下载的ipa文件 Potatso Lite打开后添加节点，节点类型选择Shadowsocks或ShadowsocksR，完成后连接选择Allow Shadowrocket打开后添加节点，节点类型选择Shadowsocks或ShadowsocksR，完成后连接选择Allow Outline在其它Shadowsocks/ShadowsocksR平台版本添加节点，在分享服务器配置中复制链接，如果复制链接无效就用复制所有服务器链接 在Outline App中添加服务器，粘贴刚才复制的链接，完成后连接选择Allow 快捷启动状态栏出现VPN图标表示启用成功，下次可以直接通过设置中的VPN直接开启 LinuxShadowsocks用pip安装shadowsocks 1pip install shadowsocks 配置服务器信息 1vim /etc/shadowsocks.json 1234567891011&#123; &quot;server&quot;:&quot;[服务器 IP]&quot;, &quot;server_port&quot;:[端口], &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;[密码]&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false, &quot;workers&quot;: 1&#125; 后台启动Shadowsocks 1nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp; 要使命令行的代理生效，还需要配置全局代理 ShadowsocksRShadowsocksR安装脚本：https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr 以CentOS为例，执行安装脚本 1yum install -y wget &amp;&amp; wget -O ssr_install.sh https://raw.githubusercontent.com/the0demiurge/CharlesScripts/master/charles/bin/ssr &amp;&amp; sh ssr_install.sh 打印出帮助信息，说明安装成功 首次安装需要调用一次install命令 1ssr install 配置服务器信息，保存后会自动启动 1ssr config 要使命令行的代理生效，还需要配置全局代理 全局代理 proxychains: https://github.com/rofl0r/proxychains-ng Shadowsocks/ShadowsocksR是一个Socket5服务，所以还需要使用proxychains把流量代理一下 克隆源码然后编译安装 12345git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make installcp src/proxychains.conf /etc/proxychains.conf 执行proxychains4打印出帮助，说明已经安装成功 配置proxychains 1vim /etc/proxychains.conf 在最后一行添加ShadowsocksR的端口，如果有socks4就删除这一行，只保留socks5 1socks5 127.0.0.1 1080 在要执行的命令时前面加proxychains4即可经过代理 1proxychains4 curl cip.cc 小米路由 小米路由版仅测试过mini型号，其它版本未测试，请慎用 开启SSH小米路由器需要先开启SSH，可以去https://d.miwifi.com/rom/ssh获取root密码，下载工具包，如图开启SSH权限 登录路由Mac直接命令行ssh root@miwifi.com，Windows可以用Xshell 脚本安装这里使用miwifi-ss的一键安装脚本 1cd /tmp &amp;&amp; rm -rf *.sh &amp;&amp; curl https://raw.githubusercontent.com/blademainer/miwifi-ss/master/miwifi.sh -o miwifi.sh &amp;&amp; chmod +x miwifi.sh &amp;&amp; sh ./miwifi.sh &amp;&amp; rm -rf *.sh 执行后选择路由器型号，填入服务器信息，等待安装结束 测试安装后会默认以1081端口PAC模式启动，用此路由下的设备打开浏览器，已经可以打开Google了 服务器配置：/etc/shadowsocks.jsongfwlist：/etc/dnsmasq.d/gfwlist.conf 123#如果修改了gfwlist，需要重启重启DNS服务及防火墙服务/etc/init.d/dnsmasq restart/etc/init.d/firewall restart 关于Shadowsocks的命令 12/etc/init.d/shadowsocks start/etc/init.d/shadowsocks enable","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiandan.in/categories/科学上网/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://xiandan.in/tags/Shadowsocks/"}]},{"title":"Shadowsocks/ShadowsocksR服务端多用户安装教程","slug":"shadowsocks-server-install","date":"2018-03-29T03:09:42.000Z","updated":"2019-07-19T13:42:54.638Z","comments":true,"path":"posts/shadowsocks-server-install.html","link":"","permalink":"https://xiandan.in/posts/shadowsocks-server-install.html","excerpt":"","text":"环境这里用的系统版本是 Ubuntu 16.04.2 x86_64Python版本是 Python 2.7.12 ShadowsocksR安装ShadowsocksR的安装可以用一键安装脚本 shadowsocks_install：https://github.com/teddysun/shadowsocks_install 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 然后根据提示设置密码和端口等等，如果不设置就直接回车，出现下面提示说明已经安装成功，并且已经是开机自启 相关命令12345启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status卸载：./shadowsocksR.sh uninstall Shadowsocks安装如果没有pip需要先安装pip 1apt install python-pip 安装好后可以用pip -V查看当前pip版本 用pip安装Shadowsocks 1pip install shadowsocks 相关命令1234启动：ssserver -c /etc/shadowsocks.json -d start停止：ssserver -c /etc/shadowsocks.json -d stop重启：ssserver -c /etc/shadowsocks.json -d restart卸载：pip uninstall shadowsocks Ubuntu设置开机启动新建shadowsocks.sh 1vim /usr/bin/shadowsocks.sh 脚本中添加启动命令 1ssserver -c /etc/shadowsocks.json -d start 给脚本赋予权限 1sudo chmod +x /usr/bin/shadowsocks.sh 在/etc/rc.local中添加一行脚本的路径 1vim /etc/rc.local 1/usr/bin/shadowsocks.sh 多用户编辑shadowsocks.json 1vim /etc/shadowsocks.json 如果shadowsocks.json是空的，就完整的复制整个json server是服务器IPport_password中分别是端口号和密码 1234567891011121314&#123; &quot;server&quot;:&quot;xxx.xxx.xxx.xxx&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;passwd1&quot;, &quot;8382&quot;: &quot;passwd2&quot;, &quot;8383&quot;: &quot;passwd3&quot;, &quot;8384&quot;: &quot;passwd4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 如果shadowsocks.json不是空的，就追加port_password在最后一个字段后面 保存后重新启动Shadowsocks Google BBR加速执行安装脚本 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 安装完成后会询问是否重启，输入y重启 重启完成后重新连接服务器，查看内核版本是否最新 1uname -r 再查看bbr是否启动，返回值包含bbr说明开启成功12sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiandan.in/categories/科学上网/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://xiandan.in/tags/Shadowsocks/"}]},{"title":"Android判断设备是否有NavigationBar(虚拟按键)并获取它的高度","slug":"android-navigationBar-height","date":"2018-02-22T06:35:23.000Z","updated":"2019-02-24T07:48:49.323Z","comments":true,"path":"posts/android-navigationBar-height.html","link":"","permalink":"https://xiandan.in/posts/android-navigationBar-height.html","excerpt":"","text":"网上对于NavigationBar的判断有很多方法，但由于国内定制系统太多，导致兼容性不太好，这里提供一个实测兼容性比较好的。 123456789101112131415161718192021222324252627282930313233343536373839/** * 判断是否有NavigationBar * * @param activity * @return */public static boolean checkHasNavigationBar(Activity activity) &#123; WindowManager windowManager = activity.getWindowManager(); Display d = windowManager.getDefaultDisplay(); DisplayMetrics realDisplayMetrics = new DisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; d.getRealMetrics(realDisplayMetrics); &#125; int realHeight = realDisplayMetrics.heightPixels; int realWidth = realDisplayMetrics.widthPixels; DisplayMetrics displayMetrics = new DisplayMetrics(); d.getMetrics(displayMetrics); int displayHeight = displayMetrics.heightPixels; int displayWidth = displayMetrics.widthPixels; return (realWidth - displayWidth) &gt; 0 || (realHeight - displayHeight) &gt; 0;&#125;/** * 获得NavigationBar的高度 */public static int getNavigationBarHeight(Activity activity) &#123; int result = 0; Resources resources = activity.getResources(); int resourceId = resources.getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0 &amp;&amp; checkHasNavigationBar(activity)) &#123; result = resources.getDimensionPixelSize(resourceId); &#125; return result;&#125;","categories":[{"name":"Android 兼容","slug":"Android-兼容","permalink":"https://xiandan.in/categories/Android-兼容/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"https://xiandan.in/tags/NavigationBar/"}]},{"title":"使用Android Studio快速发布开源库到JCenter","slug":"android-upload-jcenter","date":"2018-02-01T10:15:57.000Z","updated":"2019-12-31T14:26:11.699Z","comments":true,"path":"posts/android-upload-jcenter.html","link":"","permalink":"https://xiandan.in/posts/android-upload-jcenter.html","excerpt":"","text":"完整示例代码https://github.com/xiandanin/jcenter-example 开始1.注册bintray先到https://bintray.com注册一个账号，支持Github、Google、Twitter直接授权登录 2.获取bintray.user和bintray.apikeybintray.user就是注册时的usernamebintray.apikey在个人中心可以看到 3.配置用户信息在工程根目录的local.properties新增bintray.user、bintray.apikey两个变量，把刚才的username和apikey填入 4.配置config.gradle将config.gradle复制到工程根目录，填写项目的信息如果不知道自己的项目适合什么开源协议，可以去微信搜索小程序开源许可证 5.引入插件和config.gradle在根目录的build.gradle引入config.gradle和插件，需要注意的是一定要放在buildscript之后，maven插件跟clean任务有冲突，这里注释掉task clean 12345plugins &#123; id &quot;com.jfrog.bintray&quot; version &quot;1.8.4&quot; id &quot;com.github.dcendents.android-maven&quot; version &quot;2.1&quot;&#125;apply from: &quot;config.gradle&quot; 6.创建Library 7.配置Library将bintray.gradle复制到刚才创建的Library Module根目录 8.引入bintray.gradle1apply from: &quot;bintray.gradle&quot; versionName和buildToolsVersion那些都可以在config.gradle配置，所以这里把多余的删掉 9.上传到bintray执行上传命令，看到BUILD SUCCESSFUL说明已经上传成功了 1./gradlew bintrayUpload 10.添加到Jcenter进入到你的bintray个人中心，进入到maven 刚刚上传的项目已经显示在这里了 点击Add to JCenter，申请添加到jcenter，会进入到申请页，会有输入框要求写备注，这个是可选的也可以不写直接确定。接下来等它审核通过就可以使用了，一般半天就可以审核完成 审核通过就会这样显示，这样就可以通过gradle直接引用库了 11.使用1implementation &apos;com.dyhdyh.example:jcenter:1.0.4&apos; 引入的格式由bintray.groupId、bintray.artifactId、version.name组成","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://xiandan.in/tags/Android-Studio/"},{"name":"JCenter","slug":"JCenter","permalink":"https://xiandan.in/tags/JCenter/"},{"name":"Gradle","slug":"Gradle","permalink":"https://xiandan.in/tags/Gradle/"}]},{"title":"IntelliJ IDEA创建SpringMVC Maven 项目 - HelloWorld","slug":"android-spring-helloworld","date":"2017-10-16T07:28:33.000Z","updated":"2019-12-31T14:26:11.695Z","comments":true,"path":"posts/android-spring-helloworld.html","link":"","permalink":"https://xiandan.in/posts/android-spring-helloworld.html","excerpt":"","text":"Github地址：https://github.com/xiandanin/SpringSample 创建新项目 创建一个新项目，Maven - Create from archetype，选中maven-archetype-webapp这个archetype 输入GroupId和ArtifactId 输入项目名称并选择项目存放的路径 配置项目结构 进入项目结构配置界面，File - Project Structure 选中Modules； 在main下创建java文件夹； 在webapp - WEB-INF 下创建views文件夹 标记java文件夹为Sources 标记resources文件夹为Resources 最终的项目结构如图 引入Spring打开pom.xml，引入Spring 123456789101112131415161718&lt;!--jstl--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 如果提示是否需要开启自动导入，选择Enable Auto-Import，否则更改了pom.xml不会自动更新 配置web.xml1234567891011&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Spring在WEB-INF下新建dispatcher-servlet.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--扫描包路径--&gt; &lt;context:component-scan base-package=&quot;com.example&quot; /&gt; &lt;!-- 开启注解 --&gt; &lt;context:annotation-config /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 静态资源(js、image等)的访问 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--ViewResolver 视图解析器--&gt; &lt;!--用于支持Servlet、JSP视图解析--&gt; &lt;bean id=&quot;jspViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 配置访问路径与视图 创建一个类命名HomeController，并注解@Controller，这个类就会被当成Controller 再加上访问路径的注解@RequestMapping(&quot;/home&quot;) 在HomeController内创建一个hello方法，在方法上注解@RequestMapping(&quot;/hello&quot;)，这样当访问http://localhost:8080/spring-helloworld/home/hello的时候，就会执行这个方法 最后return &quot;hello&quot;，这样执行完hello方法后会跳转到hello.jsp（hello.jsp需要建在WEB-INF-views下） 配置Tomcat 添加一个Tomcat服务+ - Tomcat Server - Local 切换到Deployment，+ - Artifact...添加当前项目的war，并设置项目访问路径为spring-helloworld 运行Tomcat 运行完成后，在浏览器访问http://localhost:8080/spring-helloworld/home/hello，就进入到hello.jsp了 *关于使用JSP如果需要在jsp使用el表达式和taglib，那还需要在pom.xml引入相应的库12345678910&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 并且在jsp的第一行加入isELIgnored = false，否则el表达式不会生效1&lt;%@page isELIgnored=&quot;false&quot; %&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xiandan.in/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiandan.in/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://xiandan.in/tags/Spring/"}]},{"title":"收集一些JetBrains授权服务器","slug":"authorization-server","date":"2017-10-10T07:58:10.000Z","updated":"2019-02-24T07:48:49.437Z","comments":true,"path":"posts/authorization-server.html","link":"","permalink":"https://xiandan.in/posts/authorization-server.html","excerpt":"","text":"2018年05月16日更新 授权服务器地址http://idea.imsxm.com/http://idea.iteblog.com/key.phphttp://xidea.online 使用说明Activate - License server - 输入授权服务器的地址 支持的版本IntelliJ IDEA 7.0 或更高ReSharper 3.1 或更高ReSharper Cpp 1.0 或更高dotTrace 5.5 或更高dotMemory 4.0 或更高dotCover 1.0 或更高RubyMine 1.0 或更高PyCharm 1.0 或更高WebStorm 1.0 或更高PhpStorm 1.0 或更高AppCode 1.0 或更高CLion 1.0 或更高","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://xiandan.in/tags/JetBrains/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://xiandan.in/tags/IntelliJ-IDEA/"},{"name":"PyCharm","slug":"PyCharm","permalink":"https://xiandan.in/tags/PyCharm/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://xiandan.in/tags/WebStorm/"},{"name":"PhpStorm","slug":"PhpStorm","permalink":"https://xiandan.in/tags/PhpStorm/"},{"name":"CLion","slug":"CLion","permalink":"https://xiandan.in/tags/CLion/"}]},{"title":"无需插件用Chrome调试WebView加载的网页","slug":"android-chrome-webview-debug","date":"2017-09-30T06:46:27.000Z","updated":"2019-02-24T07:48:49.438Z","comments":true,"path":"posts/android-chrome-webview-debug.html","link":"","permalink":"https://xiandan.in/posts/android-chrome-webview-debug.html","excerpt":"","text":"前言有时候我们需要在WebView上打开网页，有的还需要两端交互，但是如果出现了问题，就很难找到问题原因，因为没法像浏览器那样可以调试。 Chrome有个黑科技就解决了这个问题，可以调试在手机上打开的任何网页，包括手机浏览器和应用内的WebView。 要求1.Chrome 32 以上版本；2.Android 4.0 以上版本。 第一步打开Chrome的菜单 - 更多工具 - 开发者工具 第二步在开发者工具的窗口，点击三个点，打开More tools - Remote devices 第三步连接USB，在手机上打开USB调试，在Remote devices选中你连接的设备，然后就会出现当前手机上打开的网页 第四步点击Inspect，就可以调试了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"Chrome","slug":"Chrome","permalink":"https://xiandan.in/tags/Chrome/"},{"name":"WebView","slug":"WebView","permalink":"https://xiandan.in/tags/WebView/"}]},{"title":"WebP官方转换工具手把手安装教程","slug":"android-webp","date":"2017-09-13T03:44:14.000Z","updated":"2019-02-24T07:48:49.391Z","comments":true,"path":"posts/android-webp.html","link":"","permalink":"https://xiandan.in/posts/android-webp.html","excerpt":"","text":"这里顺便提供一个webp工具webp-spring WebP官网https://developers.google.com/speed/webp/ 下载依赖库要使用WebP，需要安装cwebp和dwebp。cwebp可以将JPEG，PNG或TIFF编码成WebP；dwebp可以将WebP解码成PNG。 关于cwebp，dwebp的介绍：https://developers.google.com/speed/webp/docs/precompiled 去仓库地址下载依赖库https://storage.googleapis.com/downloads.webmproject.org/releases/webp/index.html 找到适合自己系统的版本，这里用Mac为例；截止本文章最新版本是0.6.0，所以我们下载libwebp-0.6.0.tar.gz libwebp-0.6.0-windows-x86.zip 适用于 Windows-x86. libwebp-0.6.0-windows-x64.zip 适用于 Windows-x64. libwebp-0.6.0-linux-x86-32.tar.gz 适用于 GNU/Linux-x86. libwebp-0.6.0-linux-x86-64.tar.gz 适用于 GNU/Linux-x86_64. libwebp-0.6.0-mac-10.12.tar.gz 适用于 Mac OS X 10.12 (Sierra). 在OS X上安装cwebp和dwebp（仅限Mac用户）*如果没有MacPorts，请先参考附录：MacPorts安装安装MacPorts 1.更新MacPorts：sudo port selfupdate 2.安装WebP：sudo port install webp 3.等待安装成功后，就可以在你的机器上使用webp了 使用cwebp将图像转换为WebP格式比如我要将image.png以80的质量转换为webp：cwebp -q 80 image.png -o image.webp 编码器，标准和高级选项文档https://developers.google.com/speed/webp/docs/cwebp 使用dwebp将WebP转换成PNG或PPMdwebp image.webp -o image.png 解码器，命令行选项文档https://developers.google.com/speed/webp/docs/cwebp 更多WebP的使用https://developers.google.com/speed/webp/docs/using 附录：MacPorts安装1.安装MacPorts需要有XCode，XCode可以直接在AppStore安装。 2.下载适合自己系统的MacPorts版本，直接安装https://guide.macports.org/#installing.macports *如果不知道自己的系统版本，可以在关于本机里查看 3.安装成功后，在终端里输入port，如果把版本号打印出来了，那就说明安装成功了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"Chrome","slug":"Chrome","permalink":"https://xiandan.in/tags/Chrome/"},{"name":"WebView","slug":"WebView","permalink":"https://xiandan.in/tags/WebView/"}]},{"title":"MediaMetadataRetrieverCompat - 获取视频信息与缩略图兼容方案","slug":"android-media-metadata-retriever-compat","date":"2017-05-27T12:07:28.000Z","updated":"2019-12-31T14:26:11.697Z","comments":true,"path":"posts/android-media-metadata-retriever-compat.html","link":"","permalink":"https://xiandan.in/posts/android-media-metadata-retriever-compat.html","excerpt":"","text":"效果 图片 音频 视频 自定义 示例APK：example-debug.apk Gradle123456789101112//必选implementation &apos;in.xiandan.mmrc:media-metadata-retriever-compat:1.2.0&apos;//可选，需要Exif支持时必选implementation &apos;com.android.support:exifinterface:28.0.0&apos;//可选，需要FFmpeg支持时必选，全平台约24Mimplementation &apos;com.github.wseemann:FFmpegMediaMetadataRetriever:1.0.14&apos;//只保留v7a，可降低至3Mndk &#123; abiFilters &apos;armeabi-v7a&apos;&#125; 数据源类型datasource 中预设了一些DataSource，以提供不同的输入源，如果需要自定义数据源，可implements DataSource或参考其它数据源 FileSource HTTPSource UriSource FileDescriptorSource OkHttpSource（图片会使用OkHttp） InputStreamSource（仅支持图片） AssetSource（仅支持图片） 设置数据源设置数据源的操作建议放在子线程 12345678MediaMetadataRetrieverCompat mmrc = new MediaMetadataRetrieverCompat();//设置数据源mmrc.setDataSource(source);//设置数据源或抛出异常mmrc.setDataSourceOrThrow(source);//设置数据源或抛出异常 并指定检索器mmrc.setDataSourceOrThrow(source, AndroidMediaMetadataRetrieverFactory.class); 获取Metadata信息123456789101112final String width = mmrc.extractMetadata(MediaMetadataKey.WIDTH);//将值转换为intfinal int width = mmrc.extractMetadataInt(MediaMetadataKey.WIDTH, 0);//将值转换为floatfinal float width = mmrc.extractMetadataFloat(MediaMetadataKey.WIDTH, 0f);//将值转换为longfinal long width = mmrc.extractMetadataLong(MediaMetadataKey.WIDTH, 0L);... 获取缩略图取帧是耗时操作，需要放在子线程，视频有4种取帧方式 1234567891011//最接近timeUs的关键帧 - 仅视频MediaMetadataKey.OPTION_CLOSEST_SYNC//最接近timeUs的帧，不一定是关键帧(性能开销较大) - 仅视频MediaMetadataKey.OPTION_CLOSEST//早于timeUs的关键帧 - 仅视频MediaMetadataKey.OPTION_PREVIOUS_SYNC//晚于timeUs的关键帧 - 仅视频MediaMetadataKey.OPTION_NEXT_SYNC 1234567891011//获取第一帧原尺寸图片mmrc.getFrameAtTime();//获取指定毫秒的原尺寸图片 注意这里传的毫秒不再是微秒mmrc.getFrameAtTime(0, MediaMetadataKey.OPTION_CLOSEST_SYNC);//获取指定毫秒的缩略图，并基于指定宽高缩放，输出的Bitmap不一定是指定宽高mmrc.getScaledFrameAtTime(0, MediaMetadataKey.OPTION_CLOSEST_SYNC, 300, 300);//获取指定毫秒的缩略图，并按指定宽高缩放裁剪，输出的Bitmap一定是指定宽高mmrc.getCenterCropFrameAtTime(0, MediaMetadataKey.OPTION_CLOSEST_SYNC, 300, 300); 全局配置12345678910111213141516//创建一个新的配置构造器MediaMetadataConfig.newBuilder() .setCustomDataSourceCallback(new MediaMetadataConfig.CustomDataSourceCallback() &#123; @Override public void setCustomDataSource(IMediaMetadataRetriever retriever, DataSource source) &#123; //当设置了自定义数据源时 会回调 &#125; &#125;) //添加格式检查器 .addFileFormatChecker(new CustomFormatChecker()) //添加自定义检索器 .addCustomRetrieverFactory(new SVGMediaMetadataRetrieverFactory()) .addCustomRetrieverFactory(new CustomMediaMetadataRetrieverFactory()) .build() //应用配置 .apply(); 自定义检索器custom 演示了以SVG文件为例如何自定义检索器 12345MediaMetadataConfig.newBuilder() .addFileFormatChecker(new CustomFormatChecker()) .addCustomRetrieverFactory(new SVGMediaMetadataRetrieverFactory()) .build() .apply(); 相关资料fresco/imageformatFFmpegMediaMetadataRetrieverMediaMetadataRetrieverImageDecoderExifInterface","categories":[{"name":"Android 开源","slug":"Android-开源","permalink":"https://xiandan.in/categories/Android-开源/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"MediaMetadataRetriever","slug":"MediaMetadataRetriever","permalink":"https://xiandan.in/tags/MediaMetadataRetriever/"}]},{"title":"CountDownTimerSupport - 更简单易用的Android倒计时器","slug":"android-countdowntimer-support","date":"2017-05-26T06:11:59.000Z","updated":"2019-12-31T14:26:11.694Z","comments":true,"path":"posts/android-countdowntimer-support.html","link":"","permalink":"https://xiandan.in/posts/android-countdowntimer-support.html","excerpt":"","text":"Github地址：https://github.com/xiandanin/CountDownTimerSupport Android倒计时器，支持开始倒计时、暂停倒计时、继续倒计时、停止倒计时、重新倒计时 示例apk 效果演示 快速开始Android Studio - 在build.gradle中引入1compile 'com.dyhdyh.support:count-down-timer:1.0.2' 初始化12345678910111213//总时长 间隔时间CountDownTimerSupport mTimer = new CountDownTimerSupport(millisInFuture, countDownInterval);mTimer.setOnCountDownTimerListener(new OnCountDownTimerListener() &#123; @Override public void onTick(long millisUntilFinished) &#123; //间隔回调 &#125; @Override public void onFinish() &#123; //计时器停止 &#125; &#125;); 启动倒计时1mTimer.start(); 暂停倒计时1mTimer.pause(); 恢复倒计时1mTimer.resume(); 停止倒计时1mTimer.stop(); 重置并启动倒计时12mTimer.reset();mTimer.start();","categories":[{"name":"Android 开源","slug":"Android-开源","permalink":"https://xiandan.in/categories/Android-开源/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"CountDownTimer","slug":"CountDownTimer","permalink":"https://xiandan.in/tags/CountDownTimer/"},{"name":"倒计时","slug":"倒计时","permalink":"https://xiandan.in/tags/倒计时/"}]},{"title":"Appium 1.5.3下Could Not Launch Appium Inspector的解决办法","slug":"appium-could-not-launch-appium-inspector","date":"2017-04-21T10:52:25.000Z","updated":"2019-02-24T07:48:49.329Z","comments":true,"path":"posts/appium-could-not-launch-appium-inspector.html","link":"","permalink":"https://xiandan.in/posts/appium-could-not-launch-appium-inspector.html","excerpt":"","text":"异常描述 appium的Github上已经有人提了类似的问题给的建议是勾选prelaunch applicationhttps://github.com/appium/appium/issues/2341#issuecomment-40477596 建议用appium-desktop，因为这版已经不维护了，感觉新版更好用一点https://github.com/appium/appium/issues/8282#issuecomment-295196989 附上appium-desktop下载地址https://github.com/appium/appium-desktop/releases","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Appium","slug":"Appium","permalink":"https://xiandan.in/tags/Appium/"}]},{"title":"Mac下安装配置Homebrew图文教程","slug":"homebrew-install","date":"2017-04-21T10:25:36.000Z","updated":"2019-02-24T07:48:49.354Z","comments":true,"path":"posts/homebrew-install.html","link":"","permalink":"https://xiandan.in/posts/homebrew-install.html","excerpt":"","text":"1.命令行工具中执行命令ruby -e &quot;$(curl --insecure -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.出现 Press RETURN to continue or any other key to abort，按回车，输入系统密码回车，然后就会开始下载。出现Installation successful说明安装成功了 3.输入brew测试一下吧","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://xiandan.in/tags/Mac/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://xiandan.in/tags/Homebrew/"}]},{"title":"分享一些实用的Android Studio插件 - 不定期更新","slug":"android-studio-plugin","date":"2017-04-21T08:01:28.000Z","updated":"2019-12-31T14:26:11.700Z","comments":true,"path":"posts/android-studio-plugin.html","link":"","permalink":"https://xiandan.in/posts/android-studio-plugin.html","excerpt":"","text":"Github - 欢迎Starhttps://github.com/xiandanin/Android-Studio-Plugin 1.GsonOrXmlFormat | GsonFormat插件地址 - https://plugins.jetbrains.com/plugin/8435-gsonorxmlformat Github - https://github.com/zzz40500/GsonFormat插件地址 - https://plugins.jetbrains.com/plugin/7654-gsonformat直接把Json给你生成对应的Model 2.Android ButterKnife ZeleznyGithub - https://github.com/avast/android-butterknife-zelezny插件地址 - https://plugins.jetbrains.com/plugin/7369-android-butterknife-zelezny选中布局，一键生成ButterKnife的代码 3.Android File GroupingGithub - https://github.com/dmytrodanylyk/folding-plugin插件地址 - https://plugins.jetbrains.com/plugin/7876-android-file-grouping可以把你工程里的文件分类，只是显示的时候分类显示，不会创建文件夹 4.Android Parcelable code generatorGithub - https://github.com/mcharmas/android-parcelable-intellij-plugin插件地址 - https://plugins.jetbrains.com/plugin/7332-android-parcelable-code-generator一键生成Parcelable的代码 5.Android Selectors GenerateGithub - https://github.com/inmite/android-selector-chapek插件地址 - https://plugins.jetbrains.com/plugin/7682-android-selectors-generate只要图片命名与状态对应，就能一键生成selector.xml，更详细的介绍可以去插件的Github 6.ECTranslationGithub - https://github.com/Skykai521/ECTranslation插件地址 - https://plugins.jetbrains.com/plugin/8469-ectranslation可以在Android Studio里使用划词翻译，可以自定义快捷键 7.Databinding SupportGithub - https://github.com/shiraji/databinding-support插件地址 - https://plugins.jetbrains.com/plugin/9271-databinding-support将普通布局一键转换DataBinding布局，还有更多用法可以去插件的Github 插件安装Preferences - Plugins - Browse repositories...- Install","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://xiandan.in/tags/Android-Studio/"},{"name":"插件","slug":"插件","permalink":"https://xiandan.in/tags/插件/"}]},{"title":"LoadingBar - 如何更优雅的使用Loading","slug":"loadingbar","date":"2017-04-16T11:41:06.000Z","updated":"2019-12-31T14:26:11.696Z","comments":true,"path":"posts/loadingbar.html","link":"","permalink":"https://xiandan.in/posts/loadingbar.html","excerpt":"","text":"Github地址：https://github.com/xiandanin/LoadingBar 前言Loading是很普遍的需求，比如请求的时候需要显示Loading，请求完成以后再取消Loading，而一般的实现方式是在布局xml里添加一个ProgressBar，但是这样写就有很多不便，每个页面的layout都要写一个ProgressBar，显示的位置也固定了，还耦合了很多代码。而LoadingBar就是为了跟方便的操作Loading而生，高度解耦，样式全部通过工厂类决定。 结构介绍LoadingBar - 适合一些显示数据的操作，比如请求列表LoadingDialog - 适合一些提交数据的操作，比如注册，登录Factory - 决定了loading的样式，自定义样式只需实现Factory 快速开始Android Studio - 在build.gradle中引入1234compile 'com.dyhdyh.loadingbar:loadingbar:1.4.7'//appcompatimplementation \"com.android.support:appcompat-v7:xxx\" LoadingBar12345678910111213141516//默认样式 loading将会覆盖在parent的内容上面LoadingBar.make(parent).show();//自定义样式//提供两种形式,loadingView更简便,loadingFactory自由度更高LoadingBar.make(parent,loadingView).show();LoadingBar.make(parent,loadingFactory).show();//完全自定义LoadingBar.make(parent,loadingFactory) .setOnClickListener(clickListener)//点击事件 .setOnLoadingBarListener(loadingBarListener)//当loadingbar取消的时候回调 .show(); //取消LoadingLoadingBar.cancel(parent); LoadingDialog1234567891011121314151617181920212223//默认样式LoadingDialog.make(context).show();//自定义样式LoadingDialog.make(context, dialogFactory).show();//完全自定义LoadingDialog.make(context, dialogFactory) .setMessage(message)//提示消息 .setCancelable(cancelable) .show();//设置更多属性Dialog dialog = LoadingDialog.make(context, dialogFactory) .setMessage(message)//提示消息 .setCancelable(cancelable) .create();dialog.setOnCancelListener(cancelListener);dialog.set...dialog.show(); //取消LoadingLoadingDialog.cancel(); 自定义Factory12345678public class CustomLoadingFactory implements LoadingFactory &#123; @Override public View onCreateView(ViewGroup parent) &#123; View loadingView = LayoutInflater.from(parent.getContext()).inflate(R.layout.layout_custom, parent,false); return loadingView; &#125;&#125; 全局配置12//自定义样式并应用于全局LoadingConfig.setFactory(loadingFactory,dialogFactory); 资源释放其实LoadingBar在cancel的时候已经释放掉了，可以不用手动释放，但是这里也提供释放的方法，根据自己需要选择 在Activity onDestroy调用，个人建议在BaseActivity，资源释放只会释放无效的资源1LoadingBar.release(); 源码解析定义结构首先我一开始就想好了，这得有三样东西，LoadingBar与LoadingDialog，用Factory来生产loading所需要的View和Dialog 定义接口两者的共同点是都会有显示，所以我定义了一个共用的接口123public interface ILoading &#123; void show();&#125; LoadingBar除了有show还得有cancel123public interface ILoadingBar extends ILoading &#123; void cancel();&#125; LoadingDialog最终都是操作Dialog，所以它得有create，再附加一些设置常用属性的方法12345678public interface ILoadingDialog extends ILoading &#123; Dialog create(); ILoadingDialog setCancelable(boolean flag); ILoadingDialog setMessage(CharSequence message);&#125; LoadingFactory onCreateView返回的View就决定了Loading长什么样1234public interface LoadingFactory &#123; View onCreateView(ViewGroup parent);&#125; DialogFactory 主要是onCreateDialog，这个方法决定了Dialog长什么样，在这里实现创建Dialog123456789101112131415161718192021public interface DialogFactory &#123; /** * 创建dialog * @param context * @return */ Dialog onCreateDialog(Context context); /** * 设置提示消息 * @param dialog * @param message */ void setMessage(Dialog dialog,CharSequence message); /** * 进入退出的动画id * @return */ @StyleRes int getAnimateStyleId();&#125; LoadingBar的实现其实就是需要两个View，mView就是factory.onCreateView返回的LoadingView，mParent就是现实1234private LoadingBar(ViewGroup parent, LoadingFactory factory) &#123; mParent = parent; mView = factory.onCreateView(mParent);&#125; 然后把mView添加到mParent里，这样mView就处于最上层，覆盖着内容，这样就达到了Loading的效果123456789public void show() &#123; if (mView != null) &#123; mView.setVisibility(View.VISIBLE); if (mView.getParent() != null) &#123; mParent.removeView(mView); &#125; mParent.addView(mView); &#125;&#125; 取消很简单，就直接把mView移除掉就好了12345678910public void cancel() &#123; if (mView != null) &#123; mView.setVisibility(View.GONE); mParent.removeView(mView); mView = null; if (this.mListener != null) &#123; this.mListener.onCancel(mParent); &#125; &#125;&#125; 值得一说的还有findSuitableParent，因为Loading是要在可覆盖的布局上才有作用的，而当parent传的是非覆盖的布局（例如LinearLayout）,这个方法会一直往外层寻找可覆盖的布局123456789101112131415161718private static ViewGroup findSuitableParent(View parent) &#123; if (parent == null) &#123; return null; &#125; View suitableParent = parent; do &#123; if (suitableParent instanceof FrameLayout || suitableParent instanceof RelativeLayout || &quot;android.support.v4.widget.DrawerLayout&quot;.equals(suitableParent.getClass().getName()) || &quot;android.support.design.widget.CoordinatorLayout&quot;.equals(suitableParent.getClass().getName()) || &quot;android.support.v7.widget.CardView&quot;.equals(suitableParent.getClass().getName())) &#123; return (ViewGroup) suitableParent; &#125; else &#123; final ViewParent viewParent = suitableParent.getParent(); suitableParent = viewParent instanceof View ? (View) viewParent : null; return (ViewGroup) suitableParent; &#125; &#125; while (suitableParent != null); &#125; LoadingDialog的实现构造方法先用factory创建了dialog，如果有动画设置动画12345678public LoadingDialog(Context context, DialogFactory factory) &#123; this.mDialog = factory.onCreateDialog(context); this.mFactory = factory; int animateStyleId = this.mFactory.getAnimateStyleId(); if (animateStyleId &gt; 0) &#123; this.mDialog.getWindow().setWindowAnimations(animateStyleId); &#125;&#125; 因为Dialog是单例，如果在Activity已经finish了再去操作做个Dialog的话，就会抛异常，所以在show与cancel的时候要先检查是否能够操作1234567891011121314151617181920212223242526public void show() &#123; if (isValid() &amp;&amp; !mDialog.isShowing()) &#123; mDialog.show(); &#125;&#125;public void cancelDialog() &#123; if (isValid() &amp;&amp; mDialog.isShowing()) &#123; mDialog.cancel(); &#125;&#125;private boolean isValid() &#123; if (mDialog != null) &#123; Context context = mDialog.getContext(); if (context instanceof ContextWrapper)&#123; context = ((ContextWrapper) context).getBaseContext(); &#125; if (context instanceof Activity) &#123; if (!((Activity) context).isFinishing()) &#123; return true; &#125; &#125; &#125; return false;&#125; 总结使用场景不局限于请求，其实还有很多异步操作都能用上比如压缩图片，也可以用LoadingDialog更多玩法等你挖掘，有问题可以去Github的issue提出","categories":[{"name":"Android 开源","slug":"Android-开源","permalink":"https://xiandan.in/categories/Android-开源/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"Loading","slug":"Loading","permalink":"https://xiandan.in/tags/Loading/"}]},{"title":"解决AndroidStudio编译出现available for offline mode的问题","slug":"available-for-offline-mode","date":"2017-04-01T14:41:57.000Z","updated":"2019-02-24T07:48:49.446Z","comments":true,"path":"posts/available-for-offline-mode.html","link":"","permalink":"https://xiandan.in/posts/available-for-offline-mode.html","excerpt":"","text":"异常全文123456Error:A problem occurred configuring project &apos;:app&apos;.&gt; Could not resolve all dependencies for configuration &apos;:app:_debugApkCopy&apos;. &gt; Could not resolve com.squareup.okhttp3:okhttp:3.5.0. Required by: retrofit-rxjava-okhttp:app:unspecified &gt; com.squareup.retrofit2:retrofit:2.1.0 &gt; No cached version of com.squareup.okhttp3:okhttp:3.5.0 available for offline mode. 解决截图是2.2的版本 Settings-Build.Execution,Deployment-Gradle–取消勾选的Offline Work，重新编译即可。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://xiandan.in/tags/Android-Studio/"}]},{"title":"用迅雷下载Genymotion的virtual device的办法","slug":"genymotion-download","date":"2017-04-01T14:25:44.000Z","updated":"2019-02-24T07:48:49.446Z","comments":true,"path":"posts/genymotion-download.html","link":"","permalink":"https://xiandan.in/posts/genymotion-download.html","excerpt":"","text":"1.先正常操作一次Add设备，然后取消 2.打开Genymotion目录Windows：C:\\Users\\用户名\\AppData\\Local\\Genymobile\\Mac：/Users/用户名/.Genymobile/ 3.打开genymotion.log文件，在里面最下面几行，找到类似如下日志 高亮的就是下载地址，直接把地址复制到迅雷去下载，下好后把ova文件放到目录 Windows：C:\\Users\\用户名\\AppData\\Local\\Genymobile\\Genymotion\\ovaMac：/Users/用户名/.Genymobile/Genymotion/ova 重启Genymotion再添加一次就行了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Genymotion","slug":"Genymotion","permalink":"https://xiandan.in/tags/Genymotion/"}]},{"title":"分享几个下载YouTube视频的网站和工具","slug":"youtube-download","date":"2017-01-02T19:09:59.000Z","updated":"2018-12-16T08:55:18.151Z","comments":true,"path":"posts/youtube-download.html","link":"","permalink":"https://xiandan.in/posts/youtube-download.html","excerpt":"","text":"硕鼠Youtube专用下载器软件，功能较多，需要代理才能解析（我个人用这个比较多） http://download.flvcd.com savefrom界面友好，可选择的清晰度较多 http://en.savefrom.net clipconverter几乎可以解析到所有的清晰度 http://www.clipconverter.cc FindYoutube可选择的清晰度较少（需要翻墙） http://www.findyoutube.com DownieMac上的视频网站下载软件，支持上百家国内外视频网站（收费） https://software.charliemonroe.net","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiandan.in/categories/科学上网/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://xiandan.in/tags/Shadowsocks/"},{"name":"YouTube","slug":"YouTube","permalink":"https://xiandan.in/tags/YouTube/"}]},{"title":"用源码解释为什么在Android Studio中Button的文本是大写","slug":"android-code-button","date":"2016-12-19T20:25:22.000Z","updated":"2019-02-24T07:48:49.443Z","comments":true,"path":"posts/android-code-button.html","link":"","permalink":"https://xiandan.in/posts/android-code-button.html","excerpt":"","text":"概述大家应该有发现，每次写一个Button的时候，英文文本总是会变成大写 解决办法只要设置属性textAllCaps为false，就可以解决了1android:textAllCaps=&quot;false&quot; 好奇宝宝点进Button的源码，可以发现textAllCaps默认就是false，那么问题来了，为什么既然是false，仍然还需要另外设置？ 深入探索1.AppCompat主题会把Button自动转为AppCompatButton，先从这里找线索； 2.直接进入AppCompat的styles.xml，先直接搜索textAllCaps看有没有结果，结果出来一个Button的样式，而这里textAllCaps的值就是true； 3.看到这个是不是拍着大腿，感觉好像明白了什么 结论在AppCompat下Button的textAllCaps默认值就是true","categories":[{"name":"Android 源码分析","slug":"Android-源码分析","permalink":"https://xiandan.in/categories/Android-源码分析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"Button","slug":"Button","permalink":"https://xiandan.in/tags/Button/"}]},{"title":"MySQL启动出现The server quit without updating PID file错误解决办法","slug":"mysql-pid-file","date":"2016-10-30T15:39:00.000Z","updated":"2019-02-24T07:48:49.368Z","comments":true,"path":"posts/mysql-pid-file.html","link":"","permalink":"https://xiandan.in/posts/mysql-pid-file.html","excerpt":"","text":"将 /etc/mysql 下的 my.cnf 文件删除，再次启动MySQL服务 删除前注意备份","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiandan.in/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiandan.in/tags/MySQL/"}]},{"title":"Android命令行用已有的keyStore对apk进行签名","slug":"android-command-signature","date":"2016-10-25T08:43:16.000Z","updated":"2019-02-24T07:48:49.327Z","comments":true,"path":"posts/android-command-signature.html","link":"","permalink":"https://xiandan.in/posts/android-command-signature.html","excerpt":"","text":"这里要用到Android SDK中的一个工具jarsigner，只要配置了SDK环境变量就可以直接使用 方法一（推荐）：复制命令到记事本保存为apk-sign.bat后运行 12345678set/p keystore_path=请输入.keystore的文件路径：set/p alias_path=请输入keystore的alias：set/p unsign_path=请输入待签名的apk文件路径：set/p sign_path=请输入签名后生成的apk文件路径：jarsigner -verbose -keystore %keystore_path% -signedjar %sign_path% %unsign_path% %alias_path%pause 运行后根据提示填上对应的信息，最后输入keystore的密码，提示jar 已签名，就大功告成了。 方法二：除了方法一也可以在命令行里直接用一行命令解决，但需要4个参数： ①keystore文件路径 ②签名后生成的apk路径 ③待签名的apk路径 ④alias别名 1jarsigner -verbose -keystore keystore文件路径 -signedjar 签名后生成的apk路径 待签名的apk路径 别名 1.例如,我已有的.keystore文件在D:\\app\\keystore的目录下,名为demo.keystore 2.待签名的apk在D:\\app\\apk的目录下,文件名是unsign.apk 3.签名后会产生一个新的apk，然后我要让新apk也生成在D:\\app\\apk目录下 4.keystore里面可能会存在多个别名，所以要注明一下别名，这里我的别名就是demo 把这4个参数合成完整的命令就是： 1jarsigner -verbose -keystore D:\\app\\keystore\\demo.keystore -signedjar D:\\app\\apk\\unsign.apkD:\\app\\apk\\sign.apk demo","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"keyStore","slug":"keyStore","permalink":"https://xiandan.in/tags/keyStore/"},{"name":"签名","slug":"签名","permalink":"https://xiandan.in/tags/签名/"}]},{"title":"Android AndroidManifest.xml文件的android:supportsRtl属性详解","slug":"android-supportsrtl-analysis","date":"2016-05-11T03:07:57.000Z","updated":"2019-02-24T07:48:49.318Z","comments":true,"path":"posts/android-supportsrtl-analysis.html","link":"","permalink":"https://xiandan.in/posts/android-supportsrtl-analysis.html","excerpt":"","text":"Android Studio新建工程的AndroidManifest文件里会有一个supportsRtl属性，并且默认是true，去看了看官网对android:supportsRtl的解释 官网原文链接：https://developer.android.google.cn/guide/topics/manifest/application-element Declares whether your application is willing to support &gt;right-to-left (RTL) layouts. If set to true and targetSdkVersion is set to 17 or higher, various RTL APIs will be activated and used by the system so your app can display RTL layouts. If set to false or if targetSdkVersion is set to 16 or lower, the RTL APIs will be ignored or will have no effect and your app will behave the same regardless of the layout direction ass ociated to the user’s Locale choice (your layouts will always be left-to-right). The default value of this attribute is false. This attribute was added in API level 17. 结合Google翻译和自己的理解翻译一下 声明你的application是否愿意支持从右到左（原来RTL就是right-to-left 的缩写）的布局。 如果设置为true，targetSdkVersion设置为17或更高，各种RTL的API将被激活，系统使用您的应用程序可以显示RTL布局。如果targetSdkVersion设置为16或更低的设置为false，RTL的API将被忽略或没有影响您的应用程序将具有相同的行为无论对用户现场的选择相关的布局方向（你的布局会从左至右）。 此属性的默认值是false。 此属性被添加到API 17。 最后一句也说了，这个属性是Android4.2以后才有的，并且默认是false，低版本并不支持这个属性。 那这个从右到左的布局是什么样的，经常玩机的朋友应该有发现，在设置-开发人员选项，有一个强制使用从右到左的布局方向，如图 打开强制使用从右到左的布局方向，原先在左边的文字被放到右边去了，在右边的开关，也被放到左边了，看到这个就明白了这个属性的意思了吧 为了证明这个属性，再弄个Demo试试 当android:supportsRtl为false的时候，即使手机开启了强制从右到左，app的布局也不会改变，如图 当android:supportsRtl为true的时候，并且手机也开启了强制从右到左的开关，那么布局就会从右到左来排列了，如图","categories":[{"name":"Android 文档","slug":"Android-文档","permalink":"https://xiandan.in/categories/Android-文档/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiandan.in/tags/Android/"},{"name":"AndroidManifest","slug":"AndroidManifest","permalink":"https://xiandan.in/tags/AndroidManifest/"}]},{"title":"使用OpenSSL生成RSA公钥和私钥","slug":"android-openssl","date":"2016-04-01T03:04:46.000Z","updated":"2019-02-24T07:48:49.408Z","comments":true,"path":"posts/android-openssl.html","link":"","permalink":"https://xiandan.in/posts/android-openssl.html","excerpt":"","text":"OpenSSL官网：https://www.openssl.org/source/ Windows下生成RSA公钥和私钥打开 openssl 文件夹下的 bin 文件夹，执行 openssl.exe 文件 生成 RSA 私钥，出现图中提示说明生成成功 1genrsa -out rsa_private_key.pem 1024 ​​ ​​ ​​生成 RSA 公钥​​1rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem ​​ ​​​​ Mac下生成RSA公钥和私钥直接执行命令openssl进入openssl 生成 RSA 私钥，出现图中提示说明生成成功 1genrsa -out rsa_private_key.pem 1024 生成 RSA 公钥 1rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 公钥和私钥会生成在你的用户文件夹下","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xiandan.in/categories/开发工具/"}],"tags":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://xiandan.in/tags/OpenSSL/"},{"name":"RSA","slug":"RSA","permalink":"https://xiandan.in/tags/RSA/"}]}]}